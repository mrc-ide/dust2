[{"path":"https://mrc-ide.github.io/dust2/articles/design.html","id":"running-multiple-realisations","dir":"Articles","previous_headings":"","what":"Running multiple realisations","title":"Principles and design of dust","text":"’s rare one might want run single stochastic simulation; normally want run group together. several ways might want : single set parameters starting state run set simulations, differ due stochasticity model addition , perhaps run different starting points, representing uncertainty initial conditions addition , run many parameter sets possibly one particle per parameter, possibly many per parameter addition , parameters grouped blocks book-keeping can get tedious error prone done hand. dust, try restrict concern points, simulation – interaction expect take longest interesting model – just run big loop time particles matter type structure might represent . See vignette(\"multi\") details interacting different ways might want structure simulations.","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/design.html","id":"parallelisation","dir":"Articles","previous_headings":"","what":"Parallelisation","title":"Principles and design of dust","text":"’re running multiple simulations , even simple simulation might start taking long time independent might look parallelism try speed simulations. However, one just draw multiple numbers single random number generator . , given generator like built R, parallel equivalent draw 10 numbers parallel rather series. drawing random number “side effect” updating random number state. random number stream also Markov chain! makes sense (us least) store state stream’s random number generator separately, n particles within dust object n separate streams, might think model state state declared user vector floating point numbers alongside random number state. model step, model state updated random number state. might seem wasteful, used popular Mersenne Twister degree particle require 2560 bytes additional state. contrast newer xoshiro generators use require 32 16 bytes state; 4 double- single-precision floating point numbers respectively. non-trivial simulation ’s large overhead. Setting seed runs trivial, particularly number simultaneous particles increases. ’ve used random numbers future package may seen raise warning configure use “L’Ecuyer-CMRG” adapts R’s native random number seeds safe parallel. reason different streams start seeds set via poor heuristics (e.g., system time thread id) might exactly . set randomly, might collide (see John Cook’s description birthday paradox ) picked sequentially ’s guarantee streams might correlated. Ideally want similar set properties R’s set.seed method; user provides arbitrary integer seed random number streams using way reproducible also statistically robust. also want streams reproducible even number particles changes, particle indices shared. random number generators use (xoshiro family, .k.. Blackmann-Vigna generators) support properties; fully described monty implemented. initialise system potentially large number particles take two steps: First, seed first stream using splitmix64 RNG, following xoshiro docs. expands single 64-bit integer 256-bits RNG state, ensuring resulting full random number seed contain zeros. , subsequent chain take “jump” sequence. special move implemented RNG equivalent large number draws generator (e.g., 2^128 default generator used double-precision models) ensuring particles state occupies non-overlapping section underlying random number stream (see vignette(\"rng\") details). setup free parallelise system realisation completely independent others; problem become “embarrassingly parallel”. practice using OpenMP available well supported R gracefully falls back serial operation available. number threads changes, results change; calculations carried random numbers drawn. Sometimes might parallelise beyond one computer (e.g., using cluster), case use OpenMP. call case “distributed parallelism” cope process take “long jump” (even larger jump random number space), within process proceed . approach taken monty package organising running MCMC chains parallel, works dust model.","code":"runif(10)"},{"path":"https://mrc-ide.github.io/dust2/articles/design.html","id":"efficient-running","dir":"Articles","previous_headings":"","what":"Efficient running","title":"Principles and design of dust","text":"general rule--thumb avoid unneeded memory allocations tight loops; sort stochastic iteration everything tight loop! However, ’ve reduced problem scope just providing update method, long issue memory allocations whole thing runs fixed space without worry.","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/design.html","id":"efficient-state-handling","dir":"Articles","previous_headings":"","what":"Efficient state handling","title":"Principles and design of dust","text":"non-trivial systems, often want record subset states - potentially small fraction total states computed. example, sircovid model track several thousand states (representing populations various stages disease transmission, different ages, different vaccination status etc), time need report tens order fit data examine key outputs. Reducing number state variables returned different points process several advantages: Saving space: run model 2000 states, 1000 replicates record trajectories 100 time steps, represents 100 million floating point numbers, 1.6 GB memory disk using double-precision numbers. unrealistic numbers, make even simple sensitivity analysis -impossible work . Saving time: copying data around surprisingly slow. enable , can restrict state returned methods; default others call . dust_system_run_to_time() returns state, simply advances system forward time dust_system_simulate() method move system forwards time returns state series points. accepts index_state argument limit states returned dust_system_state() method returns model state accepts argument index_state state return use idea “packers”, monty help work state. ordering state important; always dimensions contain: model states within single particle particles within time-step (may several dimensions; see vignette(\"multi\")) time dimension using simulate particle filter minimise repeatedly moving around data writing, help concatenation. Multiple particles data stored consecutively read written order. time step written . can append states different times easily. base-R aperm() function useful reshaping output different dimension order require one, can slow. order pull , allocate memory front, C++ pass back R “pointer” memory, live long model object. means even model requires gigabytes memory run, never copied back forth R (subject R’s copy--write semantics instead accessed needed, written -place following C++ reference semantics.","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/design.html","id":"useful-verbs","dir":"Articles","previous_headings":"","what":"Useful verbs","title":"Principles and design of dust","text":"try provide verbs useful, given model presents largely opaque pointer model state. Normally system contain several things: random number state: effectively matrix integers (either uint32_t uint64_t) system state: effectively matrix floating point numbers, (typically double) immutable “shared” state, particles within parameter group can read write running (can updated runs). immutable can safely shared copies system accessed simultaneously different threads. system internal state, mutable particle can read write , used buffer calculations. keep one per parameter set per thread different threads can safely mutate state. Importantly, space assumed unimportant specifying model state (.e., can shuffle reset model state leaving “internal” data behind). Given , sorts verbs need include: Running system time point (dust_system_run_to_time()) - runs system’s update method many times required reach new time point, returning model state time point. useful might want change system time point, continue. continuous time models use ODE solver using system’s deriv method compute rates. Running model collecting history (dust_system_simulate()) - dust_system_run_to_time() also collects partial state number times along way. always one dimension dust_system_state() (time). Setting model state (dust_system_set_state()) - leaves RNG state parameters untouched replaces model state particles. useful model initialisation performing arbitrary model state /parameter changes. addition, specific methods oriented towards particle filtering: Reordering particles (dust_system_reorder()) - shuffles particle state among particles within parameter set. useful implementing resampling algorithms updates state (dust_system_set_state(), leaving RNG state internal state untouched) Run bootstrap particle filter (dust_filter_create()) implemented using methods, case model provides compare function. provides interface monty used dust_likelihood_monty()","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/design.html","id":"a-compilation-target","dir":"Articles","previous_headings":"","what":"A compilation target","title":"Principles and design of dust","text":"esoteric design dust make convenient use target programs. use package primarily target models written odin2. allows user write models high level, describing updates steps. random walk example beginning document might implemented designed two systems play well together user can write models high level generate code works well within framework efficiently runs parallel. sircovid used model hundreds logical compartments may structured, interface R level remains toy models used documentation .","code":"sd <- parameter()          # user-provided standard deviation initial(y) <- 0            # starting point of the simulation update(y) <- Normal(y, sd) # take random step each time step"},{"path":"https://mrc-ide.github.io/dust2/articles/details.html","id":"influential-environment-variables-and-options","dir":"Articles","previous_headings":"","what":"Influential environment variables and options","title":"Details","text":"DUST_WORKDIR_ROOT: environment variable sets root working directory compilation code. Normally, use session-specific directory, good choice. might want change cases: want generate models process want outlive lifetime process (e.g., running models HPC) want cache compilation across sessions set environment variable, ’ll create models , name pattern dust_<hash> <hash> hash generated code. means model changes ’ll still recompile . DUST_QUIET: environment variable controls default level verbosity compiling dust models. Set truthy value (e.g., TRUE) change default. can always overridden providing value quiet argument dust_compile() dust_package(). DUST_DEBUG: environment variable controls pkgload::compile_dll() compiles C++ code. Set truthy value (e.g., TRUE) disable optimisation, allows faster compilation cost slower runtime. can overridden debug argument dust_compile().","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/dust2.html","id":"a-simple-example---random-walk","dir":"Articles","previous_headings":"","what":"A simple example - random walk","title":"Introduction to dust","text":"Consider unbiased random walk; time step move position draw normal distribution mean 0 standard deviation. consider single individual moving eventually simulate family individuals, independent. simulations sense time - unitless measure time “step” used ’s interpreted (time non-negative integer, implemented using size_t). example, ’ll use built-example package: However, also bundled package can loaded : walk dust_system_generator object: Create instance system using dust_system_create(). returns dust_system object can used simulate interact system. example, initial model state one row per model state variable (one ) one column per particle (20). systems start zero state unless set via dust_system_set_state(), dust_system_set_state_initial() running system. can run system 100 time steps, return state end walk (intermediate times): point particles run 100 time steps standard deviation 1 step distributed following Normal(0, 10). easier see simulate lot particles, 20,000:","code":"walk <- dust_example(\"walk\") walk #>  #> ── <dust_system_generator: walk> ─────────────────────────────────────────────── #> ℹ This system runs in discrete time with a default dt of 1 #> ℹ This system has 3 parameters #> → 'sd', 'len', and 'random_initial' #> ℹ Use dust2::dust_system_create() (`?dust2::dust_system_create()`) to create a system with this generator #> ℹ Use coef() (`?stats::coef()`) to get more information on parameters sys <- dust_system_create(walk, list(sd = 1), n_particles = 20) sys #>  #> ── <dust_system: walk> ───────────────────────────────────────────────────────── #> ℹ 1 state x 20 particles #> ℹ This system runs in discrete time with dt = 1 #> ℹ This system has 1 parameter that can be updated via `dust_system_update_pars` #> → 'sd' #> ℹ Use coef() (`?stats::coef()`) to get more information on parameters dust_system_state(sys) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] #> [1,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #>      [,15] [,16] [,17] [,18] [,19] [,20] #> [1,]     0     0     0     0     0     0 dust_system_run_to_time(sys, 100) dust_system_state(sys) #>           [,1]       [,2]     [,3]     [,4]     [,5]      [,6]     [,7] #> [1,] -2.069917 -0.9781523 8.965475 5.710992 17.03536 -4.266331 6.208208 #>          [,8]      [,9]     [,10]     [,11]    [,12]     [,13]     [,14] #> [1,] 1.202825 -20.75184 -6.728591 0.2456902 7.762512 -7.534014 -4.132089 #>          [,15]     [,16]    [,17]     [,18]    [,19]     [,20] #> [1,] -5.865048 -16.15312 23.93168 -18.12983 3.208677 -1.279874 sys <- dust_system_create(walk, list(sd = 1), n_particles = 20000) dust_system_run_to_time(sys, 100) hist(dust_system_state(sys), freq = FALSE, las = 1, col = \"steelblue2\", main = \"\",      ylim = c(0., 0.04), xlab = \"State\") curve(dnorm(x, 0, 10), col = \"orange\", add = TRUE, lwd = 2)"},{"path":"https://mrc-ide.github.io/dust2/articles/dust2.html","id":"running-a-model-in-parallel","dir":"Articles","previous_headings":"A simple example - random walk","what":"Running a model in parallel","title":"Introduction to dust","text":"approach still runs everything serial, one particle another. can configure system run parallel providing extra argument n_threads constructor. Provided computer can compile OpenMP following code execute parallel using 2 threads use many random number generators particles, run fewer particles , increase threads decrease, results (see vignette(\"design\") ). careful selecting number threads. dust never use one thread time without requested, avoid using parallel::detectCores() work many threads available often return overestimate. particularly case shared-use system cluster CRAN’s servers.","code":"sys <- dust_system_create(walk, list(sd = 1), n_particles = 20, n_threads = 2) dust_system_run_to_time(sys, 100) dust_system_state(sys) #>           [,1]      [,2]      [,3]     [,4]     [,5]     [,6]      [,7] #> [1,] -7.798794 -4.706807 -6.580274 12.30675 10.50923 9.982649 -9.252921 #>          [,8]    [,9]    [,10]     [,11]    [,12]     [,13]    [,14]     [,15] #> [1,] 3.452613 4.99186 6.299646 -5.948605 8.729621 -7.338344 8.081076 0.1275727 #>         [,16]    [,17]     [,18]     [,19]     [,20] #> [1,] 8.244453 6.885286 -9.878333 -11.25054 -3.151811"},{"path":"https://mrc-ide.github.io/dust2/articles/dust2.html","id":"a-more-interesting-example","dir":"Articles","previous_headings":"","what":"A more interesting example","title":"Introduction to dust","text":"Consider now SIR model (Susceptible - Infected - Recovered). sort model common epidemiology, often extended add additional compartments (e.g., SEIR adds Exposed compartment) structuring compartment based properties age. , show simple example just 3 compartments, plus two tracking cumulative infections daily infections. model initialised way : system non-trivial initial state; can set dust_system_set_state_initial(): 5 states per particle, 5 x 2 matrix. order run simulation beginning--end, use $simulate method dust object, runs set time steps records state . Let’s 200 particles:x output 5 x 200 x 151 matrix (n state x n particles x n times) can use dust_unpack_state convert list--matrices: state$cases_inc 200 (particle) 151 (time step) matrix. Note need transposing plotting. Plotting time, see:","code":"sir <- dust_example(\"sir\") sys <- dust_system_create(sir, list(), n_particles = 2) dust_system_state(sys) #>      [,1] [,2] #> [1,]    0    0 #> [2,]    0    0 #> [3,]    0    0 #> [4,]    0    0 #> [5,]    0    0 dust_system_set_state_initial(sys) dust_system_state(sys) #>      [,1] [,2] #> [1,]  990  990 #> [2,]   10   10 #> [3,]    0    0 #> [4,]    0    0 #> [5,]    0    0 sys <- dust_system_create(sir, list(), n_particles = 200) dust_system_set_state_initial(sys) times <- seq(0, 150) state <- dust_system_simulate(sys, times) dim(state) #> [1]   5 200 151 state <- dust_unpack_state(sys, state) names(state) #> [1] \"S\"           \"I\"           \"R\"           \"cases_cumul\" \"cases_inc\" dim(state$cases_inc) #> [1] 200 151 matplot(times, t(state$I), type = \"l\", lty = 1, col = \"#00000022\",         xlab = \"Time\", ylab = \"Number infected (I)\") lines(times, colMeans(state$I), col = \"red\", lwd = 2)"},{"path":"https://mrc-ide.github.io/dust2/articles/dust2.html","id":"other-methods","dir":"Articles","previous_headings":"","what":"Other methods","title":"Introduction to dust","text":"methods dust objects may useful.","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/dust2.html","id":"reordering-particles","dir":"Articles","previous_headings":"Other methods","what":"Reordering particles","title":"Introduction to dust","text":"method exists support particle filtering, allows resampling reordering particles. Suppose wanted reorder particles decreasing order: pass index reorder method: can continue random walk. need sample every particle particles can appear multiple times sample, total number must conserved. Suppose want sample particles based close 0: can apply sampling: terribly useful key part particle filter. reordering happens, model state copied around; internal data random number state left behind.","code":"sys <- dust_system_create(walk, list(sd = 1), n_particles = 20) dust_system_run_to_time(sys, 1) dust_system_state(sys) #>           [,1]     [,2]       [,3]     [,4]      [,5]     [,6]      [,7] #> [1,] 0.4197933 0.250539 0.01482815 1.448195 0.5231619 0.820422 0.2495565 #>            [,8]      [,9]  [,10]    [,11]     [,12]      [,13]      [,14] #> [1,] -0.3809611 0.3352818 1.9442 0.229384 -1.492759 -0.1146346 -0.3091399 #>          [,15]      [,16]     [,17]     [,18]      [,19]      [,20] #> [1,] 0.4338285 -0.1675469 0.7650757 -1.294391 -0.6569056 -0.5690646 index <- order(dust_system_state(sys)) index #>  [1] 12 18 19 20  8 14 16 13  3 11  7  2  9  1 15  5 17  6  4 10 dust_system_reorder(sys, index) dust_system_state(sys) #>           [,1]      [,2]       [,3]       [,4]       [,5]       [,6]       [,7] #> [1,] -1.492759 -1.294391 -0.6569056 -0.5690646 -0.3809611 -0.3091399 -0.1675469 #>            [,8]       [,9]    [,10]     [,11]    [,12]     [,13]     [,14] #> [1,] -0.1146346 0.01482815 0.229384 0.2495565 0.250539 0.3352818 0.4197933 #>          [,15]     [,16]     [,17]    [,18]    [,19]  [,20] #> [1,] 0.4338285 0.5231619 0.7650757 0.820422 1.448195 1.9442 p <- dnorm(dust_system_state(sys)) index <- sample(length(p), replace = TRUE , prob = p) index #>  [1]  2 15 15  9 10  7 16  6  4  5 16 20  6  3  2 10 15  8 11  6 dust_system_reorder(sys, index) dust_system_state(sys) #>           [,1]      [,2]      [,3]       [,4]     [,5]       [,6]      [,7] #> [1,] -1.294391 0.4338285 0.4338285 0.01482815 0.229384 -0.1675469 0.5231619 #>            [,8]       [,9]      [,10]     [,11]  [,12]      [,13]      [,14] #> [1,] -0.3091399 -0.5690646 -0.3809611 0.5231619 1.9442 -0.3091399 -0.6569056 #>          [,15]    [,16]     [,17]      [,18]     [,19]      [,20] #> [1,] -1.294391 0.229384 0.4338285 -0.1146346 0.2495565 -0.3091399"},{"path":"https://mrc-ide.github.io/dust2/articles/dust2.html","id":"set-particle-state","dir":"Articles","previous_headings":"Other methods","what":"Set particle state","title":"Introduction to dust","text":"particle state determined three mutable things; pars, state time; can updated model created. found setting one time important; Resetting model new set parameters (pars), initial conditions (state) times (time) Changing pars point simulation introduce new aspect model Changing state manually move around individuals within model Setting time along state initialising model previously saved state update_state method allows setting components. default every particle starts initial condition specified model classes initial() method. However, can specify state directly using $update_state() method. , initialise SIR model 1 infected individual rather 10: Now, run model, far epidemics fail take infected individual disappears infecting anyone.  can optionally set initial time along state. useful model depends time (e.g., use time step calculation transforming meaningful measure time). can also set initial state range different values. Suppose set initial number infections Poisson distributed mean 10, might write:","code":"sys <- dust_system_create(sir, list(), n_particles = 20) dust_system_set_state(sys, matrix(c(1000, 1, 0, 0, 0), 5, 1)) dust_system_state(sys) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] #> [1,] 1000 1000 1000 1000 1000 1000 1000 1000 1000  1000  1000  1000  1000  1000 #> [2,]    1    1    1    1    1    1    1    1    1     1     1     1     1     1 #> [3,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #> [4,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #> [5,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #>      [,15] [,16] [,17] [,18] [,19] [,20] #> [1,]  1000  1000  1000  1000  1000  1000 #> [2,]     1     1     1     1     1     1 #> [3,]     0     0     0     0     0     0 #> [4,]     0     0     0     0     0     0 #> [5,]     0     0     0     0     0     0 state <- dust_system_simulate(sys, times) state <- dust_unpack_state(sys, state) matplot(times, t(state$I), type = \"l\", lty = 1, col = \"#00000022\",         xlab = \"Day\", ylab = \"Number infected (I)\") I0 <- rpois(20, 10) state0 <- rbind(1010 - I0, I0, 0, 0, 0, deparse.level = 0) dust_system_set_state(sys, state0) dust_system_set_time(sys, 0) dust_system_time(sys) #> [1] 0 dust_system_state(sys) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] #> [1,] 1001 1002 1000 1003  998  999  998  998 1000  1007   999   997  1003  1002 #> [2,]    9    8   10    7   12   11   12   12   10     3    11    13     7     8 #> [3,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #> [4,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #> [5,]    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #>      [,15] [,16] [,17] [,18] [,19] [,20] #> [1,]   999   996  1001   999  1001  1005 #> [2,]    11    14     9    11     9     5 #> [3,]     0     0     0     0     0     0 #> [4,]     0     0     0     0     0     0 #> [5,]     0     0     0     0     0     0"},{"path":"https://mrc-ide.github.io/dust2/articles/migrating.html","id":"dude-wheres-my-feature","dir":"Articles","previous_headings":"","what":"Dude, where’s my feature?","title":"Migrating from dust 1.x.x","text":"Features now found elsewhere: random number generation support now found monty; affects users. Features now included: particle filter now fully implemented dust, longer part mcstate (now monty) yet implemented: GPU compilation (rewrite planned 2025) “Restart” particle filter Multi-phase systems (believed used except sircovid)","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/migrating.html","id":"change-in-meaning-of-time-in-discrete-time-models","dir":"Articles","previous_headings":"","what":"Change in meaning of time in discrete-time models","title":"Migrating from dust 1.x.x","text":"Previously, discrete time models used step count steps forward unsigned integers, usually zero. Many systems added parameter (constant) dt representing timestep variable time represented time real-valued number. example might dt 0.25 system stops times [0, 0.25, 0.5, 0.75, 1] steps [0, 1, 2, 3, 4]. created point difference continuous time models, (still ) based real-valued time, particularly confusing “mixed time” systems mix discrete-time continuous-time components. dust2, time systems real valued, starts 0 default, though can set initialisation. discrete time models, default dt 1 (though default can changed system generator, see vignette(\"writing\")), means never thought dt can use dust2 without thinking .","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/migrating.html","id":"new-interface","dir":"Articles","previous_headings":"","what":"New interface","title":"Migrating from dust 1.x.x","text":"new interface completely different, following feedback discoverability documentation features within package. ’ve also generally tried make functions self-contained, less magic, easier understand. lesser-used functions removed entirely. apologise inconvenience cause migrating old code, unfortunately done automatically. Previously, dust generators “R6 classes”, created using $new() interacted using methods (e.g., sys$run(). contrast, dust2 uses free functions create systems interact systems created. table, consider dust system sir, available via dust_example() versions package. dust 1.0.0 allocate system 10 particles, set initial conditions, run forward 20 time units return state matrix writing: dust2 write lines version 2, predictable easier find documentation. First core methods represent usage: longer set initial conditions model longer returns state end $update_state() method always complex Access read-properties changed slightly, typically just dropping function call. Previously, number particles much less well defined (running multiple groups always implemented support running single group). n_particles now represents number particles per group. less used methods removed entirely: $shape(): previously returned dimension structure among groups. currently support concept believe anyone used . $run_adjoint(): support proof--concept calculation derivatives, moved dust_likelihood_last_gradient() $set_index(), $index(): concept “index” support efficient running particle filter implemented R mcstate package. two “indexes” consider - one saving trajectories comparison data. particle filter now entirely written C++ longer needed. $set_stochastic_schedule(): concept “stochastic schedule” support mixed time models. schedule now set via dt construction. $resample(): existed debug particle filter longer needed. $info(): mostly used return information packing variables within model state. now done “packers”; see dust_unpack_state() dust_unpack_index() $has_gpu_support(), $uses_gpu(), $get_gpu_info(): longer support GPU models $real_size(): longer encourage running single precision (needed running GPUs) $rng_algorithm(): can change random number generation algorithm, typically -one $set_data(), $filter(): methods existed support previous version particle filter. Data longer set system one now use dust_filter_create() dust_unfilter_create()","code":"sir <- dust_example(\"sir\") sys <- sir$new(pars = list(dt = 1), time = 0, n_particles = 10) sys$run(10) sir <- dust_example(\"sir\") sys <- dust_system_create(sir, pars = list(), time = 0, n_particles = 10) dust_system_set_state_initial(sys) dust_system_run_to_time(sys, 10) dust_system_state(sys) ##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,]  958  954  954  932  979  983  926  953  967   957 ## [2,]   26   29   33   50   10    6   52   26   16    25 ## [3,]   16   17   13   18   11   11   22   21   17    18 ## [4,]   32   36   36   58   11    7   64   37   23    33 ## [5,]    4    4    4    8    0    2   11    3    1     3"},{"path":"https://mrc-ide.github.io/dust2/articles/migrating.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See also","title":"Migrating from dust 1.x.x","text":"odin2 migration guide","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/periodic.html","id":"discrete-time-systems","dir":"Articles","previous_headings":"","what":"Discrete time systems","title":"Periodic variables details","text":"start discrete time systems ’re much easier think , consider case SIR system package, ’ll write hand (relax tweaked simulate allow returning fractional days, think). relevant section update() method looks like : , unpack S state vector, compute per-individual probability moving S (p_SI), draw total number individuals move S (n_SI) using binomial distribution. Finally, accumulate incidence state (state_next[4]). , don’t anything cause reset day. Instead, define zero_every method arranges us: initializer-list syntax bit gory {{1, {4}}} reads “every 1 time unit zero variables index 4”, want . running system apply update function , daily cases increases. end day (step increases time integer value) incidence value peak, returned dust_system_state() system run. zeroing happens just first call update() start run away eligible time. even though system operates discrete time can think happening t + eps. trick discrete time models easy guaranteed visit time step turn, guarantee integer-valued time visited (eventually), require periods used resetting integer-like (compute 0.25-daily incidence example).","code":"const auto S = state[0]; const auto I = state[1]; const auto p_SI = 1 - monty::math::exp(-shared.beta * I / shared.N * dt); const auto n_SI = monty::random::binomial<real_type>(rng_state, S, p_SI); state_next[4] += n_SI; static auto zero_every(const shared_state& shared) {   return dust2::zero_every_type<real_type>{{1, {4}}}; }"},{"path":"https://mrc-ide.github.io/dust2/articles/periodic.html","id":"continuous-time-systems","dir":"Articles","previous_headings":"","what":"Continuous time systems","title":"Periodic variables details","text":"turns can trick continuous time systems, , though ’s much less obvious works. continuous time system, difficulty can’t guaranteed land exactly times corresponding reset periods, though turns time probably typically align places data. Consider resetting variables immediately start step. end performing check every step. look see passed reset time previous step. consider events along real line, time end previous step current step compute, interval question, many complete divisions interval possible. previous step current step n divisions (, ⌊ti/period⌋\\lfloor t_i / period \\rfloor) within period reset required, current step divisions previous passed one () resettings.  Consider figure illustrates situation. Time runs along x axis days, dotted vertical lines indicate beginnings weeks (every 7 days, conventional). first pair points figure move day 15 18, week 2 (⌊15/2⌋=2\\lfloor 15 / 2 \\rfloor = 2); end step don’t need consider resetting weekly variables. middle pair points run day 19 24, crossing middle week 2 week 3. end previous step, weekly-reset variables hold values need resetting, need continuing integration. third set points also need resetting; landed exactly boundary week 2 3, first thing need starting reset values accumulate week 3. situation common ’ll often resetting variables aligned data, solver stop exactly times data. fourth case, jump two reset values, OK , even though never hold correct value week 2, also never use value week 2. still need reset continuing ’ve crossed least one boundary. decided reset, need make changes values. case landed exactly boundary (common ’d think; see ) easy; can just zero value variables question! case part-way interval complex though. true second fourth cases . need compute value target function time reset subtract current value variables reset. exploit Dormand-Prince solver’s “dense output”, allows us interpolate variable interval previous interval. fourth case jumped two intervals, calculation happens final interval. ’s one remaining wrinkle, happens end integration. Consider points final steps taken solver end integration (beginning step resetting variables corrected ). case, fourth case problem step passed new interval need apply reset. step taken us 13 25 jumping resets 14 21. look value variables 21 subtract final values held, now values accumulated week 3.","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/periodic.html","id":"properties-of-resettable-variables","dir":"Articles","previous_headings":"","what":"Properties of resettable variables","title":"Periodic variables details","text":"implementation makes assumptions variables hard prove dust2 , responsible satisfying . ’ll try make sure odin2 can satisfy never need worry though (even don’t need worry anything vignette). accumulate ; ode systems rate ingress depend never read part system. important many parts integration hold incorrect value. discrete time systems incremental addition (e.g., +=).","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/periodic.html","id":"unresolved-bits-that-might-change","dir":"Articles","previous_headings":"","what":"Unresolved bits that might change","title":"Periodic variables details","text":"’s possible offset reset happens; ’s every 1 unit happens times 0, 1, 2, etc. ’s every 7 units time 0, 7, 14, etc.","code":""},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"first-steps-a-random-walk","dir":"Articles","previous_headings":"","what":"First steps, a random walk","title":"Writing dust2 systems","text":"Consider unbiased random walk; time step move position draw normal distribution mean 0 standard deviation. implement model dust write C++ file looks like: code sits inside class, though class every method static (deleted constructor writing walk() = delete; emphasise ). dust class definitions components, order terribly important: series annotations (comments starting // [[dust2::) type declarations struct definitions series static methods. , types arguments must match interface described consider pieces turn , consider values might used place.","code":"#include <dust2/common.hpp>  // [[dust2::class(walk)]] // [[dust2::time_type(discrete)]] // [[dust2::parameter(sd)]] class walk { public:   walk() = delete;    using real_type = double;    struct shared_state {     real_type sd;   };    struct internal_state {};    using rng_state_type = monty::random::generator<real_type>;    static dust2::packing packing_state(const shared_state& shared) {     return dust2::packing{{\"x\", {}}};   }    static shared_state build_shared(cpp11::list pars) {     const auto sd = dust2::r::read_real(pars, \"sd\");     return shared_state{sd};   }    static void update_shared(cpp11::list pars, shared_state& shared) {     shared.sd = dust2::r::read_real(pars, \"sd\", shared.sd);   }    static void initial(real_type time,                       const shared_state& shared,                       internal_state& internal,                       rng_state_type& rng_state,                       real_type * state_next) {     state_next[0] = 0;   }    static void update(real_type time,                      real_type dt,                      const real_type * state,                      const shared_state& shared,                      internal_state& internal,                      rng_state_type& rng_state,                      real_type * state_next) {     state_next[0] = monty::random::normal(rng_state, state[0], shared.sd * dt);   } };"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"support-code","dir":"Articles","previous_headings":"First steps, a random walk","what":"Support code","title":"Writing dust2 systems","text":"include header dust2; path compiler find arranged R using LinkingTo system. include must present.","code":"#include <dust2/common.hpp>"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"annotations","dir":"Articles","previous_headings":"First steps, a random walk","what":"Annotations","title":"Writing dust2 systems","text":"first annotation tells dust2 name class contains system definition. may seem obvious computers actually clever ’s best blunt . second annotation tells dust2 discrete-time (opposed continuous time) system: wanted continuous time system ODEs instead written: later rest code different; discuss later. remaining annotations tell dust2 parameters. use help communicate users system inputs generator accepts. really documentation rather controlling parameters processed build_shared update_shared methods described , keep sync. prefer, go directly code handles parameter. information surfaced R via print coef methods generator system objects. annotations use // [[dust2::name(<value>)]] - specify different name R system class name // [[dust2::default_dt(<value>)]] - specify default value dt // [[dust2::has_compare()]] - required support comparison data // [[dust2::has_adjoint()]] - required support likelihood gradients describe later.","code":"// [[dust2::class(walk)]] // [[dust2::time_type(discrete)]] // [[dust2::time_type(continuous)]] // [[dust2::parameter(sd)]]"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"type-definitions","dir":"Articles","previous_headings":"First steps, a random walk","what":"Type definitions","title":"Writing dust2 systems","text":"first type need one real type (might change , depending rewriting currently-absent GPU interface goes). now least must include line ’s best exactly written . come C background, using statement lot like writing typedef double real_type; except arguments go way around contains equals sign. Second, shared state: Values shared_state quantities, often parameters, vary system initialised (running dust_system_update_pars()) shared across particles group. read-system running (indeed non-parameter methods ). can include derived quantities . model one element, sd, represent standard deviation random walk time unit. Third, empty internal state: Internal state particle-specific state can used scratch space particle can read write evaluates tied specific particle. Finally, random number state: real_type , designed flexibility dust version 1 may need , may change future. However, need convenient name type, best left .","code":"using real_type = double; struct shared_state {     real_type sd;   }; struct internal_state {}; using rng_state_type = monty::random::generator<real_type>;"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"the-methods","dir":"Articles","previous_headings":"First steps, a random walk","what":"The methods","title":"Writing dust2 systems","text":"First , describe state packed. single compartment x, scalar. described packing : {} indicates x scalar. vector length within braces (e.g., {3} {shared.len}) matrix two elements. ’ll describe fully later. Next, build_shared, takes R list (cpp11::list) converts shared_state type. implementation can whatever fancy. , used dust convenience function dust2::r::read_real convert R element sd pars real construct struct . might written manually something like: find cpp11 conversion functions produce error messages hard action; list pars element sd, name sd occur within error message user really know gone wrong. first sort interesting method initial, computes initial conditions system. Though case ’s trivial ’s terribly interesting: function takes argument: time, time system initialised. initial conditions don’t depend time ignore , systems find useful. shared, read (const) reference shared data (system struct containing sd). ignore well. internal, mutable reference internal state, empty struct. ignore well. rng_state, state random number generator particle; use generate random numbers , don’t, unsurprised read ignore one . state_next, system state initialising. one write , contain exit initial conditions. Note state_next raw pointer, bit gross used modern C++, writing middle big state vector includes particles. responsibility write past end (can write exactly one number complex systems state particle quite long). used C++20 might used ranges support nicely. actual implementation trivial; zero initial condition! finally update method, usually bulk system implementation: initial quite arguments: time, initial time start step dt, size time step (move time + dt) state, read-(const) pointer state start step shared, internal rng_state, initial state_next, mutable pointer state end step. general pattern read variables state, calculations write state_next, . use monty random library sample normal distribution, referencing previous state state[0], using standard deviation process shared_state (shared.sd) scaled dt using random number state rng_state, writing back state_next.","code":"static dust2::packing packing_state(const shared_state& shared) {     return dust2::packing{{\"x\", {}}};   } static shared_state build_shared(cpp11::list pars) {     const auto sd = dust2::r::read_real(pars, \"sd\");     return shared_state{sd};   } static shared_state build_shared(cpp11::list pars) {     real_type sd = cpp11::as_cpp<real_type>(pars[\"sd\"]);     return shared_state{sd};   } static void initial(real_type time,                       const shared_state& shared,                       internal_state& internal,                       rng_state_type& rng_state,                       real_type * state_next) {     state_next[0] = 0;   } static void update(real_type time,                      real_type dt,                      const real_type * state,                      const shared_state& shared,                      internal_state& internal,                      rng_state_type& rng_state,                      real_type * state_next) {     state_next[0] = monty::random::normal(rng_state, state[0], shared.sd * dt);   }"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"multiple-variables-the-sir-revisited","dir":"Articles","previous_headings":"","what":"Multiple variables, the SIR revisited","title":"Writing dust2 systems","text":"Slightly interestingly, consider SIR model used elsewhere docs (dust_example(\"sir\") elsewhere). , ’ll show minimal implementation , shows features: shows basically pattern random walk model , highlight additions differences. packing_state method looks interesting potentially useful now: , four variables; S, R compartments cases_inc holds daily incidence (number new cases per day). random walk model, still scalars (second element pair still {}) four elements now order determined order presented . build_shared update_shared really changed nature, note ’ve chosen support updating three parameters within update_shared (I0, gamma beta). parameters N exp_noise can set initialisation. ’ve added new type data_type build_data method creates . data_type struct can hold arbitrary data, used represent observation one data streams single point time. running within particle filter (see dust_filter_create()) data.frame representing time series observations. initial condition function now actually sets initial condition! first element (S; see packing_state) set N - I0 second element () set I0 remaining two states zeroed. update method similar nature random walk model, just bit longer: update cases_inc deserves extra attention: might think simply compute cumulative cases, right zero_every method: declares every 1 time unit (first element inner {}) zero data element(s) {3}. latter argument might vector, saying {7, {3, 4, 5}} read “every 7 time units, zero elements 3 5”. outer {} allows us multiple different zeroed variables, write dust2::zero_every_type<real_type>{{1, {3}, {7, {4}}} added another variable weekly incidence. Finally, compare_data: long sort call signature initial update read-state read-data. , return single real number, log-likelihood point. example add small random noise modelled data (avoid NaNs modelled cases zero) compute log density Poisson distribution observing cases data.","code":"#include <dust2/common.hpp>  // [[dust2::class(sir)]] // [[dust2::time_type(discrete)]] // [[dust2::has_compare()]] // [[dust2::parameter(I0, constant = FALSE)]] // [[dust2::parameter(N, constant = TRUE)]] // [[dust2::parameter(beta, constant = FALSE)]] // [[dust2::parameter(gamma, constant = FALSE)]] // [[dust2::parameter(exp_noise, constant = TRUE)]] class sir { public:   sir() = delete;    using real_type = double;    struct shared_state {     real_type N;     real_type I0;     real_type beta;     real_type gamma;     real_type exp_noise;   };    struct internal_state {};    struct data_type {     real_type incidence;   };    using rng_state_type = monty::random::generator<real_type>;    static dust2::packing packing_state(const shared_state& shared) {     return dust2::packing{{\"S\", {}}, {\"I\", {}}, {\"R\", {}}, {\"cases_inc\", {}}};   }    static shared_state build_shared(cpp11::list pars) {     const real_type I0 = dust2::r::read_real(pars, \"I0\", 10);     const real_type N = dust2::r::read_real(pars, \"N\", 1000);     const real_type beta = dust2::r::read_real(pars, \"beta\", 0.2);     const real_type gamma = dust2::r::read_real(pars, \"gamma\", 0.1);     const real_type exp_noise = dust2::r::read_real(pars, \"exp_noise\", 1e6);     return shared_state{N, I0, beta, gamma, exp_noise};   }    static void update_shared(cpp11::list pars, shared_state& shared) {     shared.I0 = dust2::r::read_real(pars, \"I0\", shared.I0);     shared.beta = dust2::r::read_real(pars, \"beta\", shared.beta);     shared.gamma = dust2::r::read_real(pars, \"gamma\", shared.gamma);   }    static data_type build_data(cpp11::list r_data, const shared_state& shared) {     auto data = static_cast<cpp11::list>(r_data);     auto incidence = dust2::r::read_real(data, \"incidence\", NA_REAL);     return data_type{incidence};   }    static void initial(real_type time,                       const shared_state& shared,                       internal_state& internal,                       rng_state_type& rng_state,                       real_type * state_next) {     state_next[0] = shared.N - shared.I0;     state_next[1] = shared.I0;     state_next[2] = 0;     state_next[3] = 0;   }    static void update(real_type time,                      real_type dt,                      const real_type * state,                      const shared_state& shared,                      internal_state& internal,                      rng_state_type& rng_state,                      real_type * state_next) {     const auto S = state[0];     const auto I = state[1];     const auto R = state[2];     const auto cases_inc = state[3];     const auto p_SI = 1 - monty::math::exp(-shared.beta * I / shared.N * dt);     const auto p_IR = 1 - monty::math::exp(-shared.gamma * dt);     const auto n_SI = monty::random::binomial<real_type>(rng_state, S, p_SI);     const auto n_IR = monty::random::binomial<real_type>(rng_state, I, p_IR);     state_next[0] = S - n_SI;     state_next[1] = I + n_SI - n_IR;     state_next[2] = R + n_IR;     state_next[3] = cases_inc + n_SI;   }    static auto zero_every(const shared_state& shared) {     return dust2::zero_every_type<real_type>{{1, {3}}};   }    static real_type compare_data(const real_type time,                                 const real_type * state,                                 const data_type& data,                                 const shared_state& shared,                                 internal_state& internal,                                 rng_state_type& rng_state) {     const auto incidence_observed = data.incidence;     if (std::isnan(data.incidence)) {       return 0;     }     const auto noise =       monty::random::exponential_rate(rng_state, shared.exp_noise);     const auto incidence_modelled = state[3];     const auto lambda = incidence_modelled + noise;     return monty::density::poisson(incidence_observed, lambda, true);   } }; static dust2::packing packing_state(const shared_state& shared) {     return dust2::packing{{\"S\", {}}, {\"I\", {}}, {\"R\", {}}, {\"cases_inc\", {}}};   } struct data_type {     real_type incidence;   }; static data_type build_data(cpp11::list r_data, const shared_state& shared) {     auto data = static_cast<cpp11::list>(r_data);     auto incidence = dust2::r::read_real(data, \"incidence\", NA_REAL);     return data_type{incidence};   } static void initial(real_type time,                       const shared_state& shared,                       internal_state& internal,                       rng_state_type& rng_state,                       real_type * state_next) {     state_next[0] = shared.N - shared.I0;     state_next[1] = shared.I0;     state_next[2] = 0;     state_next[3] = 0;   } static void update(real_type time,                      real_type dt,                      const real_type * state,                      const shared_state& shared,                      internal_state& internal,                      rng_state_type& rng_state,                      real_type * state_next) {     const auto S = state[0];     const auto I = state[1];     const auto R = state[2];     const auto cases_inc = state[3];     const auto p_SI = 1 - monty::math::exp(-shared.beta * I / shared.N * dt);     const auto p_IR = 1 - monty::math::exp(-shared.gamma * dt);     const auto n_SI = monty::random::binomial<real_type>(rng_state, S, p_SI);     const auto n_IR = monty::random::binomial<real_type>(rng_state, I, p_IR);     state_next[0] = S - n_SI;     state_next[1] = I + n_SI - n_IR;     state_next[2] = R + n_IR;     state_next[3] = cases_inc + n_SI;   } state_next[3] = cases_inc + n_SI; static auto zero_every(const shared_state& shared) {     return dust2::zero_every_type<real_type>{{1, {3}}};   } static real_type compare_data(const real_type time,                                 const real_type * state,                                 const data_type& data,                                 const shared_state& shared,                                 internal_state& internal,                                 rng_state_type& rng_state) {     const auto incidence_observed = data.incidence;     if (std::isnan(data.incidence)) {       return 0;     }     const auto noise =       monty::random::exponential_rate(rng_state, shared.exp_noise);     const auto incidence_modelled = state[3];     const auto lambda = incidence_modelled + noise;     return monty::density::poisson(incidence_observed, lambda, true);   }"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"continuous-time-ode-models","dir":"Articles","previous_headings":"","what":"Continuous time (ODE) models","title":"Writing dust2 systems","text":"interface looks slightly different ODE models, updating system one time next computing rate change given time ODE solver updating values system. rather update() method, write rhs() method. implementation follows sir model , little changed: made changes annotations, replaced update rhs updated compare_data, otherwise everything remains (except minor change dropping exp_noise parameter needed ). annotations replaced rhs method follows sir model’s update one closely, returns rates state_deriv rather updating state_next. Note function accept rng_state argument. compare_data method changed slightly longer add random noise modelled data:","code":"#include <dust2/common.hpp>  // [[dust2::class(sirode)]] // [[dust2::time_type(continuous)]] // [[dust2::has_compare()]] // [[dust2::parameter(I0, constant = FALSE)]] // [[dust2::parameter(N, constant = TRUE)]] // [[dust2::parameter(beta, constant = FALSE)]] // [[dust2::parameter(gamma, constant = FALSE)]] class sirode { public:   sirode() = delete;    using real_type = double;    struct shared_state {     real_type N;     real_type I0;     real_type beta;     real_type gamma;   };    struct internal_state {};    struct data_type {     real_type incidence;   };    using rng_state_type = monty::random::generator<real_type>;    static dust2::packing packing_state(const shared_state& shared) {     return dust2::packing{{\"S\", {}}, {\"I\", {}}, {\"R\", {}}, {\"cases_inc\", {}}};   }    static shared_state build_shared(cpp11::list pars) {     const real_type I0 = dust2::r::read_real(pars, \"I0\", 10);     const real_type N = dust2::r::read_real(pars, \"N\", 1000);     const real_type beta = dust2::r::read_real(pars, \"beta\", 0.2);     const real_type gamma = dust2::r::read_real(pars, \"gamma\", 0.1);     return shared_state{N, I0, beta, gamma};   }    static void update_shared(cpp11::list pars, shared_state& shared) {     shared.I0 = dust2::r::read_real(pars, \"I0\", shared.I0);     shared.beta = dust2::r::read_real(pars, \"beta\", shared.beta);     shared.gamma = dust2::r::read_real(pars, \"gamma\", shared.gamma);   }    static data_type build_data(cpp11::list r_data, const shared_state& shared) {     auto data = static_cast<cpp11::list>(r_data);     auto incidence = dust2::r::read_real(data, \"incidence\", NA_REAL);     return data_type{incidence};   }    static void initial(real_type time,                       const shared_state& shared,                       internal_state& internal,                       rng_state_type& rng_state,                       real_type * state_next) {     state_next[0] = shared.N - shared.I0;     state_next[1] = shared.I0;     state_next[2] = 0;     state_next[3] = 0;   }    static void rhs(real_type time,                   const real_type * state,                   const shared_state& shared,                   internal_state& internal,                   real_type * state_deriv) {     const auto S = state[0];     const auto I = state[1];     const auto rate_SI = shared.beta * S * I / shared.N;     const auto rate_IR = shared.gamma * I;     state_deriv[0] = -rate_SI;     state_deriv[1] = rate_SI - rate_IR;     state_deriv[2] = rate_IR;     state_deriv[3] = rate_SI;   }    static auto zero_every(const shared_state& shared) {     return dust2::zero_every_type<real_type>{{1, {3}}};   }    static real_type compare_data(const real_type time,                                 const real_type * state,                                 const data_type& data,                                 const shared_state& shared,                                 internal_state& internal,                                 rng_state_type& rng_state) {     const auto incidence_observed = data.incidence;     if (std::isnan(incidence_observed)) {       return 0;     }     const auto lambda = state[3];     return monty::density::poisson(incidence_observed, lambda, true);   } }; // [[dust2::time_type(discrete)]] // [[dust2::time_type(continous)]] static void rhs(real_type time,                   const real_type * state,                   const shared_state& shared,                   internal_state& internal,                   real_type * state_deriv) {     const auto S = state[0];     const auto I = state[1];     const auto rate_SI = shared.beta * S * I / shared.N;     const auto rate_IR = shared.gamma * I;     state_deriv[0] = -rate_SI;     state_deriv[1] = rate_SI - rate_IR;     state_deriv[2] = rate_IR;     state_deriv[3] = rate_SI;   } static real_type compare_data(const real_type time,                                 const real_type * state,                                 const data_type& data,                                 const shared_state& shared,                                 internal_state& internal,                                 rng_state_type& rng_state) {     const auto incidence_observed = data.incidence;     if (std::isnan(incidence_observed)) {       return 0;     }     const auto lambda = state[3];     return monty::density::poisson(incidence_observed, lambda, true);   }"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"continuous-time-models-with-additional-output","dir":"Articles","previous_headings":"","what":"Continuous time models with additional output","title":"Writing dust2 systems","text":"Sometimes convenient models variables updated ODEs, variables compound expression variables. can always post processing, can save pulling lot data back R allow reusing values computed shared object. , list variables normal packing_state make sure final variables. Suppose sirode model , wanted track N, total population size (ignore parameter assume perhaps open system aggregating age groups). write: add additional “variable” state. write indicate last 1 entry packing_state ODE variable. Finally define set 5th element state sum first three (N = S + + R). Note takes state read-write variable constant variable.","code":"static dust2::packing packing_state(const shared_state& shared) {     return dust2::packing{{\"S\", {}}, {\"I\", {}}, {\"R\", {}}, {\"cases_inc\", {}}, {\"N\", {}}};   } static size_t size_output() {     return 1;   } static void output(real_type time,                      real_type * state,                      const shared_state& shared,                      internal_state& internal) {     state[4] = state[0] + state[1] + state[2];   }"},{"path":"https://mrc-ide.github.io/dust2/articles/writing.html","id":"continuous-time-models-with-special-variables","dir":"Articles","previous_headings":"","what":"Continuous time models with special variables","title":"Writing dust2 systems","text":"third class variables need consider, ; variables form part model state, update part rhs; allow referenced calculations, changed rhs. can changed : event update function, mixed-time models part initial conditions (e.g., via dust_system_set_state) total state vector composed series logical components, specified packing_state(). three non-overlapping “blocks” components, order: ode variables - always present input, rhs must produce derivative , value can looked anywhere. must provide initial condition. special variables - always present input, excluded calculation derivatives. must provide initial condition, must update within update() function (used). may also change within events. output variables - present output, present initial conditions, looked .","code":""},{"path":"https://mrc-ide.github.io/dust2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Rich FitzJohn. Author, maintainer. Imperial College Science, Technology Medicine. Copyright holder.","code":""},{"path":"https://mrc-ide.github.io/dust2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"FitzJohn R (2025). dust2: Next Generation dust. R package version 0.3.28, https://github.com/mrc-ide/dust2.","code":"@Manual{,   title = {dust2: Next Generation dust},   author = {Rich FitzJohn},   year = {2025},   note = {R package version 0.3.28},   url = {https://github.com/mrc-ide/dust2}, }"},{"path":"https://mrc-ide.github.io/dust2/index.html","id":"dust2-","dir":"","previous_headings":"","what":"Next Generation dust","title":"Next Generation dust","text":"dust2 package provides engine running dynamical systems discrete continuous time processes stochastic deterministic. focus Markov models problem reduces describing model state changes function current state (possibly time) without reference come . Superficially, problem hard (see vignette(\"design\")), dust2 takes care many practical bookkeeping details : Running systems parallel multi-core machines, even involving random numbers Providing useful verbs efficiently working groups simulations (different parameters, starting conditions stochastic realisations) Comparing simulations time-series data, implementing sequential Monte Carlo methods bootstrap particle filter","code":""},{"path":"https://mrc-ide.github.io/dust2/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get started","title":"Next Generation dust","text":"vignette(\"design\") describes problems dust tries solve (read package website) vignette(\"dust2\") describes dust example, showing two simple systems methods can drive (read package website) used dust version 1 , see migration guide see changed. odin2 way dust2 systems written odin & monty book shows package works context vignette(\"writing\") shows write dust2 system hand C++ vignette(\"packaging\") describes package system easy reuse","code":""},{"path":"https://mrc-ide.github.io/dust2/index.html","id":"roadmap","dir":"","previous_headings":"","what":"Roadmap","title":"Next Generation dust","text":"package ground-rewrite dust eventually become version 2.0.0 dust, release CRAN. exists separately now facilitate development use alongside original dust, developed parallel odin2 monty (previously mcstate). functionality originally found mcstate previous version dust can now found monty (e.g., random number library).","code":""},{"path":"https://mrc-ide.github.io/dust2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Next Generation dust","text":"Please install r-universe: prefer, can install GitHub remotes:","code":"install.packages(   \"dust2\",   repos = c(\"https://mrc-ide.r-universe.dev\", \"https://cloud.r-project.org\")) remotes::install_github(\"mrc-ide/dust2\", upgrade = FALSE)"},{"path":"https://mrc-ide.github.io/dust2/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Next Generation dust","text":"MIT © Imperial College Science, Technology Medicine","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_browser.html","id":null,"dir":"Reference","previous_headings":"","what":"The dust debugger — dust_browser","title":"The dust debugger — dust_browser","text":"Control browser-based debugging dust models.  help page documents three functions can used control browser enabled.  enter debugger functions; enabled present C++ code (using odin2 enabled ).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_browser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The dust debugger — dust_browser","text":"","code":"dust_browser_enabled(value = TRUE)  dust_browser_verbosity(level)  dust_browser_continue()"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_browser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The dust debugger — dust_browser","text":"value Logical, TRUE debugger enabled, FALSE otherwise. level verbosity level, string.  must one values quiet (prevents informational messages), normal (prints single line entry) verbose (prints several informational messages entry).  default normal.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_browser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The dust debugger — dust_browser","text":"dust_browser_enabled dust_browser_verbosity return previous value option setting.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_browser.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The dust debugger — dust_browser","text":"dust2 includes extremely simple debugging system, reading message, good chance inside . built top R's browser() usual tips, tricks issues working apply.  recommend setting R option browserNLdisabled = TRUE avoid surprises pressing <enter>. can press n c proceed next enabled iteration can press Q quit browser (end error time control back) commands established browser, disabled.  means variable called n need work (n) (.e. parentheses).  applies browser's command variables (c, f, n, s, r Q); please see browser information. time environment created, variables model copied environment; can see running ls() write expressions involving objects.  Changes make R (currently) propagated back running system. enable debugger, may many iterations get control returned back console.  can run dust_debug_continue() prevent entry debugger control passed back ; means time series run completion next time run system debugger triggered .  Alternatively, can run dust_debug_enabled(FALSE) disable calls debugger.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_compile.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile a dust2 system — dust_compile","title":"Compile a dust2 system — dust_compile","text":"Compile dust2 system C++ input file.  function compile dust support around system return object can call arguments make dust_system_generator object, suitable using dust functions (starting dust_system_create).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_compile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile a dust2 system — dust_compile","text":"","code":"dust_compile(   filename,   quiet = NULL,   workdir = NULL,   linking_to = NULL,   cpp_std = NULL,   compiler_options = NULL,   optimisation_level = NULL,   debug = NULL,   skip_cache = FALSE )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_compile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile a dust2 system — dust_compile","text":"filename path single C++ file quiet Logical, indicating compilation messages pkgbuild displayed.  Error messages displayed compilation failure regardless value used. NULL given, take value DUST_QUIET set, FALSE otherwise. workdir Optional working directory use.  NULL, behaviour depends existence environment variable DUST_WORKDIR_ROOT.  unset use session-specific temporary directory (generated tempfile()).  DUST_WORKDIR_ROOT set, use stable generated filename within directory, allows different sessions effectively share cache.  pass directory name string, use directory write code, allows inspect generated code.  See vignette(\"details\") information. linking_to Optionally, character vector additional packages add DESCRIPTION's LinkingTo field. Use system pulls C++ code packaged within another package's header-library. cpp_std C++ standard use, need set one explicitly. See section \"Using C++ code\" \"Writing R extensions\" details , interacts R version currently used. R 4.0.0 , C++11 used; dust depends least version R never need specify version low. Sensible options C++14, C++17, etc, depending features need compiler supports. compiler_options character vector additional options pass C++ compiler. passed without shell quoting validation, check generated commands outputs carefully case error. Note R apply anything personal Makevars. optimisation_level shorthand way specifying common compiler options control optimisation level. default (NULL) options generated , optimisation level depend user Makevars file. Valid options none disables optimisation (-O0), faster compile much slower, standard enables standard level optimisation (-O2), useful Makevars/pkgload configuration disabling optimisation, max (-O3 --fast-math) enables slower--compile potentially unsafe optimisations.  options applied compiler_options may override options provided . Note compiler_options, R apply anything personal Makevars debug Passed pkgbuild::compile_dll, build debug library. NULL given, take value DUST_DEBUG set, FALSE otherwise. skip_cache Logical, indicating cache previously compiled systems skipped. TRUE system looked cache, added cache compilation.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_compile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile a dust2 system — dust_compile","text":"function, can called arguments yield dust_system_generator function.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Example generators — dust_example","title":"Example generators — dust_example","text":"Load example generators dust2.  generators exist primarily examples documentation (yet) interesting.  examples likely change package evolves may removed.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example generators — dust_example","text":"","code":"dust_example(name)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Example generators — dust_example","text":"name name generator string; one sir, sirode walk.  See Details.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Example generators — dust_example","text":"dust_generator object, might pass dust_system_create","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example generators — dust_example","text":"models exist source code package; view sir model write:","code":"file.show(system.file(\"examples/sir.cpp\", package = \"dust2\"))"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"sir","dir":"Reference","previous_headings":"","what":"sir","title":"Example generators — dust_example","text":"simple SIR (Susceptible-Infected-Recovered) compartmental model. model parameters: N: total population size I0: initial infected population size (using dust_system_set_state_initial) beta: per-contact rate infection gamma: rate recovery exp_noise: noise parameter used comparison data system compartments S, , R, cases_cumul cases_inc","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"sirode","dir":"Reference","previous_headings":"","what":"sirode","title":"Example generators — dust_example","text":"model sir continuous time, deterministically","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"walk","dir":"Reference","previous_headings":"","what":"walk","title":"Example generators — dust_example","text":"random walk discrete time Gaussian increments.  model parameters: sd: standard deviation Gaussian update (per unit time) len: number independent walks random_initial`: Boolean, indicating initial position random (changes dust_system_set_state_initial initialise system)","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Example generators — dust_example","text":"","code":"walk <- dust_example(\"walk\") walk #>  #> ── <dust_system_generator: walk> ─────────────────────────────────────────────── #> ℹ This system runs in discrete time with a default dt of 1 #> ℹ This system has 3 parameters #> → 'sd', 'len', and 'random_initial' #> ℹ Use dust2::dust_system_create() (`?dust2::dust_system_create()`) to create a system with this generator #> ℹ Use coef() (`?stats::coef()`) to get more information on parameters  sys <- dust_system_create(walk, list(sd = 1), 20) y <- dust_system_simulate(sys, 0:50) matplot(t(y[1, , ]), type = \"l\", col = \"#0000ff55\", lty = 1,         xlab = \"Time\", ylab = \"Value\")"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a particle filter — dust_filter_create","title":"Create a particle filter — dust_filter_create","text":"Create particle filter object","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a particle filter — dust_filter_create","text":"","code":"dust_filter_create(   generator,   time_start,   data,   n_particles,   n_groups = NULL,   dt = NULL,   ode_control = NULL,   shared_data = FALSE,   n_threads = 1,   preserve_group_dimension = FALSE,   seed = NULL )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a particle filter — dust_filter_create","text":"generator system generator object, class dust_system_generator.  system must support compare_data used function. time_start start time simulation - typically first data point.  Must integer-like value. data data fit .  can data.frame, case passed dust_filter_data validation, can dust_filter_data-augmented data.frame.  times comparison taken , time_start must later earliest time. n_particles number particles run.  Larger numbers give lower variance likelihood estimate run slowly. n_groups number parameter groups.  NULL, taken data.  given, number groups data checked number. dt time step discrete time systems, defaults 1 given.  error provide non-NULL argument continuous-time systems. ode_control ODE integration control continuous time systems.  Defaults default return dust_ode_control. error provide discrete-time systems. shared_data Logical, indicating data shared among groups. n_threads Integer, number threads use parallelisable calculations.  See Details. preserve_group_dimension Logical, indicating state output system preserve group dimension case single group run.  case one group run, argument effect dimension always preserved. seed Optionally, seed.  Otherwise respond R's RNG seed initialisation.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a particle filter — dust_filter_create","text":"dust_likelihood object, can used dust_likelihood_run","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data — dust_filter_data","title":"Prepare data — dust_filter_data","text":"Prepare data use dust_unfilter_create dust_filter_create.  use function name data.frame standard column names (.e., time column containing time) called within filter functions directly.  However, can use validate data separately use different columns defaults.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data — dust_filter_data","text":"","code":"dust_filter_data(data, time = NULL, group = NULL)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data — dust_filter_data","text":"data data.frame containing time data fit.  default expect column time (one name given argument time) one columns data fit . time Optional name column within data use time. group Optional name column within data use groups","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_filter_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data — dust_filter_data","text":"data.frame, addition class attribute dust_filter_data; created modify object.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_copy.html","id":null,"dir":"Reference","previous_headings":"","what":"Create copy of a dust likelihood object — dust_likelihood_copy","title":"Create copy of a dust likelihood object — dust_likelihood_copy","text":"Create independent copy likelihood object.  new object decoupled random number streams parent object. also decoupled state size parent object, can use create new object system fundamentally different everything else .","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_copy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create copy of a dust likelihood object — dust_likelihood_copy","text":"","code":"dust_likelihood_copy(obj, seed = NULL)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_copy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create copy of a dust likelihood object — dust_likelihood_copy","text":"obj dust_filter object, created dust_filter_create dust_unfilter object created dust_unfilter_create seed seed particle filter (see dust_filter_create)","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_copy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create copy of a dust likelihood object — dust_likelihood_copy","text":"new dust_likelihood object","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch last likelihood gradient — dust_likelihood_last_gradient","title":"Fetch last likelihood gradient — dust_likelihood_last_gradient","text":"Fetch last gradient created running likelihood.  errors last call dust_likelihood_run use adjoint = TRUE.  first time call (particular set parameters) trigger running reverse model.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch last likelihood gradient — dust_likelihood_last_gradient","text":"","code":"dust_likelihood_last_gradient(obj)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch last likelihood gradient — dust_likelihood_last_gradient","text":"obj dust_filter object, created dust_filter_create dust_unfilter object created dust_unfilter_create","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch last likelihood gradient — dust_likelihood_last_gradient","text":"vector (ungrouped) matrix (grouped).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_snapshots.html","id":null,"dir":"Reference","previous_headings":"","what":"Get likelihood snapshots — dust_likelihood_last_snapshots","title":"Get likelihood snapshots — dust_likelihood_last_snapshots","text":"Get last snapshots likelihood.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_snapshots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get likelihood snapshots — dust_likelihood_last_snapshots","text":"","code":"dust_likelihood_last_snapshots(obj, select_random_particle = FALSE)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_snapshots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get likelihood snapshots — dust_likelihood_last_snapshots","text":"obj dust_filter object, created dust_filter_create dust_unfilter object created dust_unfilter_create select_random_particle Logical, indicating return history one randomly selected particle (rather entire set trajectories particles).  TRUE, particle selected independently group, object grouped.  option intended help select representative trajectory MCMC.  TRUE, drop particle dimension return value.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_snapshots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get likelihood snapshots — dust_likelihood_last_snapshots","text":"array.  ungrouped dimensions state x particle x time (time along snapshot times), grouped state x particle x group x time.  select_random_particle = TRUE, second (particle) dimension dropped.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Get likelihood state — dust_likelihood_last_state","title":"Get likelihood state — dust_likelihood_last_state","text":"Get last state likelihood.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get likelihood state — dust_likelihood_last_state","text":"","code":"dust_likelihood_last_state(obj, select_random_particle = FALSE)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get likelihood state — dust_likelihood_last_state","text":"obj dust_filter object, created dust_filter_create dust_unfilter object created dust_unfilter_create select_random_particle Logical, indicating return history one randomly selected particle (rather entire set trajectories particles).  TRUE, particle selected independently group, object grouped.  option intended help select representative trajectory MCMC.  TRUE, drop particle dimension return value.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get likelihood state — dust_likelihood_last_state","text":"array.  ungrouped dimensions state x particle, grouped state x particle x group.  select_random_particle = TRUE, second (particle) dimension dropped.  state returned dust_likelihood_last_trajectories without time dimension also without state index applied (.e., always return state).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_trajectories.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch last likelihood trajectories — dust_likelihood_last_trajectories","title":"Fetch last likelihood trajectories — dust_likelihood_last_trajectories","text":"Fetch last trajectories created running likelihood.  errors last call dust_likelihood_run use save_trajectories = TRUE.  return states groups run via index_state index_group arguments dust_likelihood_run.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_trajectories.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch last likelihood trajectories — dust_likelihood_last_trajectories","text":"","code":"dust_likelihood_last_trajectories(obj, select_random_particle = FALSE)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_trajectories.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch last likelihood trajectories — dust_likelihood_last_trajectories","text":"obj dust_filter object, created dust_filter_create dust_unfilter object created dust_unfilter_create select_random_particle Logical, indicating return history one randomly selected particle (rather entire set trajectories particles).  TRUE, particle selected independently group, object grouped.  option intended help select representative trajectory MCMC.  TRUE, drop particle dimension return value.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_last_trajectories.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch last likelihood trajectories — dust_likelihood_last_trajectories","text":"array.  ungrouped dimensions state x particle x time, grouped state x particle x group x time.  select_random_particle = TRUE, second (particle) dimension dropped.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_monty.html","id":null,"dir":"Reference","previous_headings":"","what":"Create monty model — dust_likelihood_monty","title":"Create monty model — dust_likelihood_monty","text":"Create monty_model dust_likelihood object.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_monty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create monty model — dust_likelihood_monty","text":"","code":"dust_likelihood_monty(   obj,   packer,   initial = NULL,   domain = NULL,   failure_is_impossible = FALSE,   save_state = FALSE,   save_trajectories = FALSE,   save_snapshots = NULL )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_monty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create monty model — dust_likelihood_monty","text":"obj dust_likelihood object, created dust_filter_create dust_unfilter_create packer parameter packer, convert unstructured vector parameters used MCMC list parameters dust system requires. initial Optionally, function create initial conditions unpacked parameters. domain Optionally, domain information pass model.  given, two column matrix row names corresponding parameter names packer, first column representing lower bound second column representing upper bound.  need specify parameters domain (-Inf, Inf) assumed.  use monty::monty_domain_expand expand logical parameters, vector-valued parameter b domain entry called b expand elements b. failure_is_impossible Logical, indicating error computing likelihood treated log-density -Inf (.e., point impossible).  big hammer use, better using domain (reflecting boundaries) priors control possible.  However, sometimes can integration failures high parameter values, just pathological parameter sets , understand model, giving parameter set continuing best option. save_state Logical, indicating state saved time series. save_trajectories Logical, indicating particle trajectories saved.  can also character vector indicating logical compartments, integer vector index state. save_snapshots Optional vector times snapshot entire state.  can restart system points.  must line exactly times filter.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_monty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create monty model — dust_likelihood_monty","text":"monty::monty_model object","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_monty.html","id":"random-number-streams","dir":"Reference","previous_headings":"","what":"Random number streams","title":"Create monty model — dust_likelihood_monty","text":"section relevant likelihood object particle filter, therefore uses random numbers. short version: seed argument may passed dust_filter_create ignored using dust_likelihood_monty model algorithms monty.  generally worry , expected. initialise filter, provide random number seed argument.  filter use n_groups * (n_particles + 1) streams (one filter group, group one per particle).  run filter directly (e.g., dust_likelihood_run advance state filter). However, use filter monty (using dust_likelihood_monty) ignore seeding. running MCMC n_chains chains, need n_chains * n_groups * (n_particles + 1) random number streams - enough streams every chain filter set chains.  monty look us, upshot random number state may previously set building filter ignored need create series suitable seeds. seeds provided monty start point RNG state space (2^256 possible states default).  MCMC, chain seed created performing \"long jump\", moving 2^192 steps along chain.  within chain take series \"jumps\" (2^128 steps) streams need across groups, filters particles. ensures independence across stochastic components system also reproducibility predictability system.  initial seeding performed monty respond R's RNG (.e., follow set.seed) explicit seed given.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_rng_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Get filter RNG state — dust_likelihood_rng_state","title":"Get filter RNG state — dust_likelihood_rng_state","text":"Get random number generator (RNG) state particle filter.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_rng_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get filter RNG state — dust_likelihood_rng_state","text":"","code":"dust_likelihood_rng_state(obj)  dust_likelihood_set_rng_state(obj, rng_state)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_rng_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get filter RNG state — dust_likelihood_rng_state","text":"obj dust_filter object, created dust_filter_create dust_unfilter object created dust_unfilter_create rng_state raw vector random number generator state, returned dust_likelihood_rng_state","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_rng_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get filter RNG state — dust_likelihood_rng_state","text":"raw vector, quite long.  Later describe might reseed filter system state.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_run.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute likelihood — dust_likelihood_run","title":"Compute likelihood — dust_likelihood_run","text":"Compute log likelihood based dynamical model, either particle filter (created dust_filter_create) deterministic model (created dust_unfilter_create).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_run.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute likelihood — dust_likelihood_run","text":"","code":"dust_likelihood_run(   obj,   pars,   initial = NULL,   save_trajectories = FALSE,   save_snapshots = NULL,   adjoint = NULL,   index_state = NULL,   index_group = NULL )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_run.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute likelihood — dust_likelihood_run","text":"obj dust_filter object, created dust_filter_create dust_unfilter object created dust_unfilter_create pars Optional parameters compute likelihood . provided, parameters updated initial Optional initial conditions, matrix (state x particle) 3d array (state x particle x group).  provided, system initial conditions used. save_trajectories Logical, indicating trajectories simulation history saved simulation runs; small overhead runtime memory. Particle trajectories saved time data.  index_state non-NULL, trajectories limited states. save_snapshots Optional vector times record snapshots entire state system. adjoint Optional logical, indicating enable adjoint history saving. enabled default model adjoint, can disabled enabled even model support adjoints! actually adjoint able compute gradients.  effect stochastic models. index_state optional vector state indices save save_trajectories TRUE.  omitted state saved save_trajectories = FALSE effect. index_group optional vector group indices run calculation .  can use run subset possible groups, obj initialised (argument must NULL first call).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_likelihood_run.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute likelihood — dust_likelihood_run","text":"vector likelihood values, many elements groups.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_ode_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dust_ode_control object. — dust_ode_control","title":"Create a dust_ode_control object. — dust_ode_control","text":"Create control object controlling adaptive stepper systems ordinary differential equations (ODEs). returned object can passed continuous-time dust model initialisation.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_ode_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dust_ode_control object. — dust_ode_control","text":"","code":"dust_ode_control(   max_steps = 10000,   atol = 1e-06,   rtol = 1e-06,   step_size_min = 0,   step_size_max = Inf,   critical_times = NULL,   debug_record_step_times = FALSE,   save_history = FALSE )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_ode_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dust_ode_control object. — dust_ode_control","text":"max_steps Maximum number steps take. integration attempts take steps , throw error, stopping integration. atol per-step absolute tolerance. rtol per-step relative tolerance.  total accuracy less . step_size_min minimum step size.  actual minimum used largest absolute value step_size_min .Machine$double.eps (single-precision equivalent support float-based models).  integration attempts make step smaller , throw error, stopping integration. step_size_max largest step size.  default maximum step size (Inf) solver can take large step wants .  short-lived fluctuations rhs solver may skip accident, specify smaller maximum step size . critical_times Vector critical times.  times guarantee integration stop, can use changes parameters.  can avoid solver jumping short-lived departures smooth solution, prevent solver learn sharp change target function . debug_record_step_times Logical, indicating step times recorded.  enabled debugging.  Step times can retrieved via dust_system_internals(). save_history Logical, indicating save history running.  enabled debugging. Data can retrieved via dust_system_internals(), format undocumented.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_ode_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dust_ode_control object. — dust_ode_control","text":"named list class \"dust_ode_control\".  modify creation.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_support.html","id":null,"dir":"Reference","previous_headings":"","what":"Information about OpenMP support — dust_openmp_support","title":"Information about OpenMP support — dust_openmp_support","text":"Return information OpenMP support machine.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_support.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Information about OpenMP support — dust_openmp_support","text":"","code":"dust_openmp_support(check_compile = FALSE)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_support.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Information about OpenMP support — dust_openmp_support","text":"check_compile Logical, indicating check can compile OpenMP program - slow first time.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_support.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Information about OpenMP support — dust_openmp_support","text":"list information OpenMP support machine. first elements come OpenMP library directly: num_proc, max_threads, thread_limit; correspond call function omp_get_<name>() C openmp_version value _OPENMP macro. logical has_openmp TRUE looks like runtime OpenMP support available next elements tell different sources might control number threads allowed run: mc.cores (R option name), OMP_THREAD_LIMIT, OMP_NUM_THREADS, MC_CORES (environment variables), limit_r (limit computed R-related control variables), limit_openmp (limit computed OpenMP-related variables) limit smaller limit_r limit_openmp Finally, specified check_compile = TRUE, logical has_openmp_compiler indicate looks like can compile OpenMP.","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_support.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Information about OpenMP support — dust_openmp_support","text":"","code":"dust_openmp_support() #> $num_procs #> [1] 4 #>  #> $max_threads #> [1] 4 #>  #> $thread_limit #> [1] 2147483647 #>  #> $openmp_version #> [1] 201511 #>  #> $has_openmp #> [1] TRUE #>  #> $mc.cores #> [1] NA #>  #> $OMP_THREAD_LIMIT #> [1] NA #>  #> $OMP_NUM_THREADS #> [1] NA #>  #> $MC_CORES #> [1] NA #>  #> $limit_r #> [1] 1 #>  #> $limit_openmp #> [1] 4 #>  #> $limit #> [1] 1 #>"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_threads.html","id":null,"dir":"Reference","previous_headings":"","what":"Select number of threads — dust_openmp_threads","title":"Select number of threads — dust_openmp_threads","text":"Politely select number threads use. See Details algorithm used.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_threads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select number of threads — dust_openmp_threads","text":"","code":"dust_openmp_threads(n = NULL, action = \"error\")"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_threads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select number of threads — dust_openmp_threads","text":"n Either NULL (select automatically) integer proposed number threads. action action perform n exceeds maximum number threads can use. Options \"error\" (default, throw error) \"fix\" (print message reduce n limit).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_threads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select number of threads — dust_openmp_threads","text":"integer, indicating number threads can use","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_threads.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select number of threads — dust_openmp_threads","text":"two limits take smaller two. first limit comes piggy-backing R's normal parallel configuration; use MC_CORES environment variable mc.cores option guide many cores happy use. take mc.cores first, MC_CORES, behaviour parallel::mclapply friends. second limit comes OpenMP. OpenMP support, use one thread (higher numbers effect case). OpenMP support, take smallest number \"processors\" (reported omp_get_num_procs()) \"max threads\" (reported omp_get_max_threads() \"thread_limit\" (reported omp_get_thread_limit(). See dust_openmp_support() values values go calculation.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_openmp_threads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select number of threads — dust_openmp_threads","text":"","code":"# Default number of threads; tries to pick something friendly, # erring on the conservative side. dust_openmp_threads(NULL) #> [1] 1  # Try to pick something silly and it will be reduced for you dust_openmp_threads(1000, action = \"fix\") #> ! Requested number of threads '1000' exceeds a limit of '1' #> ℹ See dust_openmp_threads() (`?dust2::dust_openmp_threads()`) for details #> [1] 1"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_package.html","id":null,"dir":"Reference","previous_headings":"","what":"Create dust system in package — dust_package","title":"Create dust system in package — dust_package","text":"Creates updates generated code set dust systems package. user-provided code assumed inst/dust series C++ files; file inst/dust/x.cpp transformed file src/x.cpp.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_package.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create dust system in package — dust_package","text":"","code":"dust_package(path, quiet = NULL)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_package.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create dust system in package — dust_package","text":"path Path package quiet Passed cpp11::cpp_register, TRUE suppresses informational notices updates cpp11 files.  NULL, uses value environment variable DUST_QUIET set FALSE otherwise.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_package.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create dust system in package — dust_package","text":"Nothing, function called side effects","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create dust system in package — dust_package","text":"Classes used within package must distinct; typically match filenames. add \"cpp11 attributes\" created functions, run cpp11::cpp_register() generated code created. package needs src/Makevars file enable OpenMP (system supports ). present suitable Makevars written, containing   following \"Writing R Extensions\" (see section \"OpenMP support\"). package contain src/Makevars file attempt edit error looks like contain lines similar. also need make sure package loads dynamic library; using roxygen, might create file (say, R/zzz.R) containing   substituting packagename package name appropriate. create entry NAMESPACE.","code":"PKG_CXXFLAGS=$(SHLIB_OPENMP_CXXFLAGS) PKG_LIBS=$(SHLIB_OPENMP_CXXFLAGS) #' @useDynLib packagename, .registration = TRUE NULL"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_compare_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare system state against data — dust_system_compare_data","title":"Compare system state against data — dust_system_compare_data","text":"Compare current system state data.  supported systems 'compare_data' support (.e., system definition includes compare_data method).  current state system (dust_system_state) compared data provided data.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_compare_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare system state against data — dust_system_compare_data","text":"","code":"dust_system_compare_data(sys, data)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_compare_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare system state against data — dust_system_compare_data","text":"sys dust_system object data data compare . system ungrouped data list elements corresponding whatever system requires.  system grouped, list many elements system groups, element corresponding data system requires.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_compare_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare system state against data — dust_system_compare_data","text":"numeric vector many elements system groups, corresponding log-likelihood data group.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dust system object — dust_system_create","title":"Create a dust system object — dust_system_create","text":"Create dust system object system generator.  allocates system sets initial set parameters.  created can use dust functions interact .","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dust system object — dust_system_create","text":"","code":"dust_system_create(   generator,   pars = list(),   n_particles = 1,   n_groups = 1,   time = 0,   dt = NULL,   ode_control = NULL,   seed = NULL,   deterministic = FALSE,   n_threads = 1,   preserve_particle_dimension = FALSE,   preserve_group_dimension = FALSE )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dust system object — dust_system_create","text":"generator system generator object, class dust_system_generator pars list parameters.  format depend system.  n_groups 1 , must list length n_groups element list parameters system.  default list() assumes system required parameters, may need pass list parameters . n_particles number particles create, defaulting single particle n_groups Optionally, number parameter groups time initial time, defaults 0 dt time step discrete time systems, defaults 1 given.  error provide non-NULL argument continuous-time systems. ode_control ODE integration control continuous time systems.  Defaults default return dust_ode_control. error provide discrete-time systems. seed Optionally, seed.  Otherwise respond R's RNG seed initialisation. deterministic Logical, indicating system allocated deterministic mode. n_threads Integer, number threads use parallelisable calculations.  See Details. preserve_particle_dimension Logical, indicating output system preserve particle dimension case single particle run.  case one particle run, argument effect dimension always preserved. preserve_group_dimension Logical, indicating state output system preserve group dimension case single group run.  case one group run, argument effect dimension always preserved.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dust system object — dust_system_create","text":"dust_system object, opaque format.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_create.html","id":"parallelisation","dir":"Reference","previous_headings":"","what":"Parallelisation","title":"Create a dust system object — dust_system_create","text":"Many calculations within dust system can parallelised straightforwardly - important typically running model (via dust_system_run_to_time dust_system_simulate) also parallelise dust_system_set_state_initial, dust_system_compare_data even dust_system_reorder.  need set number threads parallelism system creation, number usefully larger n_particles (n_particles * n_groups grouped system).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_internals.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch system internals — dust_system_internals","title":"Fetch system internals — dust_system_internals","text":"Return internal data system.  intended debugging , formats subject change.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_internals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch system internals — dust_system_internals","text":"","code":"dust_system_internals(   sys,   include_coefficients = FALSE,   include_history = FALSE )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_internals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch system internals — dust_system_internals","text":"sys dust_system object include_coefficients Boolean, indicating interpolation coefficients included output.  intentionally undocumented now. include_history Boolean, also undocumented.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_internals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch system internals — dust_system_internals","text":"sys discrete-time system, function returns NULL, internal data stored.  Otherwise, continuous-time system return data.frame statistics one row per particle.  columns simple integers numeric values, dydt (current derivative target function respect time) step_times (times solver stopped , debug_record_step_times dust_ode_control set TRUE) list columns, element numeric vector.  include_coefficients TRUE, coefficients column exists holds list coefficients (structure may change time, ).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_reorder.html","id":null,"dir":"Reference","previous_headings":"","what":"Reorder states — dust_system_reorder","title":"Reorder states — dust_system_reorder","text":"Reorder states within system.  function primarily used debugging may removed interface generally useful.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_reorder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reorder states — dust_system_reorder","text":"","code":"dust_system_reorder(sys, index)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_reorder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reorder states — dust_system_reorder","text":"sys dust_system object index parameter ordering.  ungrouped system vector element parameter index (element j reordering ith particle state previously used j).  elements must lie [1, n_particles], repetition index allowed (many new particles may state one old particle). system grouped, index must matrix n_particles rows n_groups columns, column corresponding reordering group.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_reorder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reorder states — dust_system_reorder","text":"Nothing, called side effects .","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_rng_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch and set rng state — dust_system_rng_state","title":"Fetch and set rng state — dust_system_rng_state","text":"Fetch, set, random number generator (RNG) state system.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_rng_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch and set rng state — dust_system_rng_state","text":"","code":"dust_system_rng_state(sys)  dust_system_set_rng_state(sys, rng_state)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_rng_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch and set rng state — dust_system_rng_state","text":"sys dust_system object rng_state raw vector random number generator state, returned dust_system_rng_state","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_rng_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch and set rng state — dust_system_rng_state","text":"raw vector, quite long.","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_run_to_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Run system — dust_system_run_to_time","title":"Run system — dust_system_run_to_time","text":"Run system, advancing time state repeatedly running update method.  can advance system time (must future).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_run_to_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run system — dust_system_run_to_time","text":"","code":"dust_system_run_to_time(sys, time)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_run_to_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run system — dust_system_run_to_time","text":"sys dust_system object time Time run ","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_run_to_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run system — dust_system_run_to_time","text":"Nothing, called side effects ","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Set system state — dust_system_set_state","title":"Set system state — dust_system_set_state","text":"Set system state.  Takes multidimensional array (2- 3d depending system grouped ).  Dimensions length 1 recycled appropriate.  continuous time systems, initialise solver immediately setting state, may cause errors initial state invalid system.  many ways can use function set different fractions state (subset states, particles parameter groups, recycling dimensions missing).  Please see Examples section usage.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set system state — dust_system_set_state","text":"","code":"dust_system_set_state(   sys,   state,   index_state = NULL,   index_particle = NULL,   index_group = NULL )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set system state — dust_system_set_state","text":"sys dust_system object state matrix array state.  ungrouped, dimension order expected state x particle.  grouped order state x particle x group.  grouped system 1 particle preserve_state_dimension = FALSE state size state x group.  can omit higher dimensions, pass vector treated higher dimensions length 1 (grouped system can provide matrix treat third dimension length 1).  provide index_ argument length corresponding state dimension must match index length. index_state index control state variables set.  can use set subset state variables. index_particle index control particles state updated index_group index control groups state updated.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set system state — dust_system_set_state","text":"Nothing, called side effects ","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set system state — dust_system_set_state","text":"","code":"# Consider a system with 3 particles and 1 group: sir <- dust_example(\"sir\") sys <- dust_system_create(sir(), list(), n_particles = 3) # The state for this system is packed as S, I, R, cases_cumul, cases_inc: dust_unpack_index(sys) #> $S #> [1] 1 #>  #> $I #> [1] 2 #>  #> $R #> [1] 3 #>  #> $cases_cumul #> [1] 4 #>  #> $cases_inc #> [1] 5 #>   # Set all particles to the same state: dust_system_set_state(sys, c(1000, 10, 0, 0, 0)) dust_system_state(sys) #>      [,1] [,2] [,3] #> [1,] 1000 1000 1000 #> [2,]   10   10   10 #> [3,]    0    0    0 #> [4,]    0    0    0 #> [5,]    0    0    0  # We can set everything to different states by passing a vector # with this shape: m <- cbind(c(1000, 10, 0, 0, 0), c(999, 11, 0, 0, 0), c(998, 12, 0, 0, 0)) dust_system_set_state(sys, m) dust_system_state(sys) #>      [,1] [,2] [,3] #> [1,] 1000  999  998 #> [2,]   10   11   12 #> [3,]    0    0    0 #> [4,]    0    0    0 #> [5,]    0    0    0  # Or set the state for just one state: dust_system_set_state(sys, 1, index_state = 4) dust_system_state(sys) #>      [,1] [,2] [,3] #> [1,] 1000  999  998 #> [2,]   10   11   12 #> [3,]    0    0    0 #> [4,]    1    1    1 #> [5,]    0    0    0  # If you want to set a different state across particles, you must # provide a *matrix* (a vector always sets the same state into # every particle) dust_system_set_state(sys, rbind(c(1, 2, 3)), index_state = 4) dust_system_state(sys) #>      [,1] [,2] [,3] #> [1,] 1000  999  998 #> [2,]   10   11   12 #> [3,]    0    0    0 #> [4,]    1    2    3 #> [5,]    0    0    0  # This will not work as it can be ambiguous what you are # trying to do: #> dust_system_set_state(sys, c(1, 2, 3), index_state = 4)  # State can be set for specific particles: dust_system_set_state(sys, c(900, 100, 0, 0, 0), index_particle = 2) dust_system_state(sys) #>      [,1] [,2] [,3] #> [1,] 1000  900  998 #> [2,]   10  100   12 #> [3,]    0    0    0 #> [4,]    1    0    3 #> [5,]    0    0    0  # And you can combine 'index_particle' with 'index_state' to set # small rectangles of state: dust_system_set_state(sys, matrix(c(1, 2, 3, 4), 2, 2),                       index_particle = 2:3, index_state = 4:5) dust_system_state(sys) #>      [,1] [,2] [,3] #> [1,] 1000  900  998 #> [2,]   10  100   12 #> [3,]    0    0    0 #> [4,]    1    1    3 #> [5,]    0    2    4"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state_initial.html","id":null,"dir":"Reference","previous_headings":"","what":"Set system state to initial conditions — dust_system_set_state_initial","title":"Set system state to initial conditions — dust_system_set_state_initial","text":"Set system state system's initial conditions.  may depend current time.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state_initial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set system state to initial conditions — dust_system_set_state_initial","text":"","code":"dust_system_set_state_initial(sys)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state_initial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set system state to initial conditions — dust_system_set_state_initial","text":"sys dust_system object","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_state_initial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set system state to initial conditions — dust_system_set_state_initial","text":"Nothing, called side effects ","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Set system time — dust_system_set_time","title":"Set system time — dust_system_set_time","text":"Set time system.  updates time provided value affect state.  may want call dust_system_set_state dust_system_set_state_initial calling .","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set system time — dust_system_set_time","text":"","code":"dust_system_set_time(sys, time)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set system time — dust_system_set_time","text":"sys dust_system object time time set.  Currently must integer-like value, future allow setting multiple dt.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_set_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set system time — dust_system_set_time","text":"Nothing, called side effects ","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate system — dust_system_simulate","title":"Simulate system — dust_system_simulate","text":"Simulate system series times, returning array output.  output can quite large, may filter states according index.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate system — dust_system_simulate","text":"","code":"dust_system_simulate(sys, times, index_state = NULL)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate system — dust_system_simulate","text":"sys dust_system object times vector times.  must increasing, first time must less current system time (reported dust_system_time).  system discrete, times must align dt used creating system. index_state optional index states extract.  given, subset system state return.  can use return fewer system states system ran , reorder states, name exit (names present index copied rownames returned array).","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate system — dust_system_simulate","text":"array 3 dimensions (state x particle x time) 4 dimensions (state x particle x group x time) grouped system.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract system state — dust_system_state","title":"Extract system state — dust_system_state","text":"Extract system state","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract system state — dust_system_state","text":"","code":"dust_system_state(   sys,   index_state = NULL,   index_particle = NULL,   index_group = NULL )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract system state — dust_system_state","text":"sys dust_system object index_state Index state fetch, like subset index_particle Index particle fetch, like subset index_group Index group fetch, like subset","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract system state — dust_system_state","text":"array system state.  system ungrouped (.e., n_groups = 1 preserve_group_dimension = FALSE), two dimensions (state, particle).  grouped, three dimensions (state, particle, group)","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch system time — dust_system_time","title":"Fetch system time — dust_system_time","text":"Fetch current time system.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch system time — dust_system_time","text":"","code":"dust_system_time(sys)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch system time — dust_system_time","text":"sys dust_system object","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch system time — dust_system_time","text":"single numeric value","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_update_pars.html","id":null,"dir":"Reference","previous_headings":"","what":"Update parameters — dust_system_update_pars","title":"Update parameters — dust_system_update_pars","text":"Update parameters used system.  can used update subset parameters change extent system, potentially faster creating new system object.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_update_pars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update parameters — dust_system_update_pars","text":"","code":"dust_system_update_pars(sys, pars)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_update_pars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update parameters — dust_system_update_pars","text":"sys dust_system object pars Parameters set system.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_system_update_pars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update parameters — dust_system_update_pars","text":"Nothing, called side effects ","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unfilter_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an unfilter — dust_unfilter_create","title":"Create an unfilter — dust_unfilter_create","text":"Create \"unfilter\" object, can used compute deterministic likelihood following algorithm particle filter, limited single particle.  name method change future.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unfilter_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an unfilter — dust_unfilter_create","text":"","code":"dust_unfilter_create(   generator,   time_start,   data,   n_particles = 1,   n_groups = NULL,   dt = NULL,   ode_control = NULL,   shared_data = FALSE,   n_threads = 1,   preserve_particle_dimension = FALSE,   preserve_group_dimension = FALSE )"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unfilter_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an unfilter — dust_unfilter_create","text":"generator system generator object, class dust_system_generator time_start start time simulation - typically first data point.  Must integer-like value. data data fit .  can data.frame, case passed dust_filter_data validation, can dust_filter_data-augmented data.frame.  times comparison taken , time_start must later earliest time. n_particles number particles run.  Typically 1, can run 1 want - currently produce likelihood provide different initial conditions see different likelihoods. n_groups Optionally, number parameter groups dt time step discrete time systems, defaults 1 given.  error provide non-NULL argument continuous-time systems. ode_control ODE integration control continuous time systems.  Defaults default return dust_ode_control. error provide discrete-time systems. shared_data Logical, indicating data shared among groups. n_threads Integer, number threads use parallelisable calculations.  See Details. preserve_particle_dimension Logical, indicating output system preserve particle dimension case single particle run.  case one particle run, argument effect dimension always preserved. preserve_group_dimension Logical, indicating state output system preserve group dimension case single group run.  case one group run, argument effect dimension always preserved.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unfilter_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an unfilter — dust_unfilter_create","text":"dust_likelihood object, can used dust_likelihood_run","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unpack.html","id":null,"dir":"Reference","previous_headings":"","what":"Unpack state — dust_unpack_state","title":"Unpack state — dust_unpack_state","text":"Unpack state.  see state come dust2 systems several places, example dust_system_state, typically unstructured vector names; useful!  However, model knows element, group elements \"means\".  can unpack state unstructured array named list using function.  idea applies higher-dimensional arrays might get system multiple particles, multiple parameter groups run multiple time steps.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unpack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unpack state — dust_unpack_state","text":"","code":"dust_unpack_state(obj, state)  dust_unpack_index(obj)"},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unpack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unpack state — dust_unpack_state","text":"obj dust_system object (dust_system_create) dust_likelihood object (dust_filter_create dust_unfilter_create). state state vector, matrix array.  might come dust_system_state, dust_likelihood_last_trajectories, dust_likelihood_last_state.","code":""},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unpack.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unpack state — dust_unpack_state","text":"named list, element corresponds logical compartment.","code":""},{"path":[]},{"path":"https://mrc-ide.github.io/dust2/reference/dust_unpack.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unpack state — dust_unpack_state","text":"","code":"sir <- dust_example(\"sir\") sys <- dust_system_create(sir, list(), n_particles = 10, dt = 0.25) dust_system_set_state_initial(sys) t <- seq(0, 100, by = 5) y <- dust_system_simulate(sys, t) # The result here is a 5 x 10 x 21 matrix: 5 states by 10 particles by # 21 times. dim(y) #> [1]  5 10 21  # The 10 particles and 21 times (following t) are simple enough, but # what are our 5 compartments?  # You can use dust_unpack_state() to reshape your output as a # list: dust_unpack_state(sys, y) #> $S #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]  990  976  964  937  898  856  810  759  686   606   528   460   390 #>  [2,]  990  971  934  869  793  693  602  496  418   365   318   290   264 #>  [3,]  990  980  965  948  918  875  833  771  688   602   514   435   375 #>  [4,]  990  977  940  913  849  772  679  577  461   388   333   287   245 #>  [5,]  990  974  930  888  819  754  678  599  512   441   392   358   330 #>  [6,]  990  982  966  938  901  840  769  687  610   515   452   395   346 #>  [7,]  990  973  946  893  841  782  710  644  586   509   449   408   367 #>  [8,]  990  974  955  929  867  774  690  599  496   423   356   305   268 #>  [9,]  990  977  964  935  899  856  809  732  617   515   436   360   317 #> [10,]  990  980  963  933  892  832  765  680  575   493   429   372   331 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] #>  [1,]   347   307   276   254   232   220   212   200 #>  [2,]   250   240   229   222   218   214   213   210 #>  [3,]   328   291   267   251   240   232   228   223 #>  [4,]   226   214   200   191   183   182   180   178 #>  [5,]   301   276   258   248   242   237   227   223 #>  [6,]   328   295   270   248   236   227   222   217 #>  [7,]   331   306   279   260   249   237   232   230 #>  [8,]   241   225   217   203   202   196   195   189 #>  [9,]   283   257   243   232   221   211   206   203 #> [10,]   301   279   262   248   240   232   226   224 #>  #> $I #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]   10   18   23   39   53   67   74   81  107   128   141   144   141 #>  [2,]   10   23   39   74  115  139  156  174  171   144   126    91    70 #>  [3,]   10   14   22   24   30   54   63   91  118   138   159   171   140 #>  [4,]   10   17   35   46   76  108  144  161  207   186   172   128   110 #>  [5,]   10   20   41   59   89  107  109  135  152   137   117    96    76 #>  [6,]   10   11   19   36   46   75  115  132  158   161   139   136   122 #>  [7,]   10   19   34   59   71   86  102  107   99   132   127   106    96 #>  [8,]   10   20   26   37   76  115  133  157  173   162   162   146   112 #>  [9,]   10   16   22   34   46   53   74  114  160   170   179   165   131 #> [10,]   10   13   24   38   64   85  107  139  174   166   151   124   114 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] #>  [1,]   113   107    89    65    51    43    34    32 #>  [2,]    49    39    32    23    17    14     7     5 #>  [3,]   114    97    78    52    41    31    24    20 #>  [4,]    78    56    36    28    25    16    11     9 #>  [5,]    69    64    56    43    34    27    25    18 #>  [6,]    89    81    72    65    46    36    25    22 #>  [7,]    92    75    76    65    45    36    28    20 #>  [8,]    91    63    43    37    23    19    16    16 #>  [9,]   102    82    74    55    48    36    25    14 #> [10,]    97    78    65    49    32    25    19     9 #>  #> $R #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    0    6   13   24   49   77  116  160  207   266   331   396   469 #>  [2,]    0    6   27   57   92  168  242  330  411   491   556   619   666 #>  [3,]    0    6   13   28   52   71  104  138  194   260   327   394   485 #>  [4,]    0    6   25   41   75  120  177  262  332   426   495   585   645 #>  [5,]    0    6   29   53   92  139  213  266  336   422   491   546   594 #>  [6,]    0    7   15   26   53   85  116  181  232   324   409   469   532 #>  [7,]    0    8   20   48   88  132  188  249  315   359   424   486   537 #>  [8,]    0    6   19   34   57  111  177  244  331   415   482   549   620 #>  [9,]    0    7   14   31   55   91  117  154  223   315   385   475   552 #> [10,]    0    7   13   29   44   83  128  181  251   341   420   504   555 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] #>  [1,]   540   586   635   681   717   737   754   768 #>  [2,]   701   721   739   755   765   772   780   785 #>  [3,]   558   612   655   697   719   737   748   757 #>  [4,]   696   730   764   781   792   802   809   813 #>  [5,]   630   660   686   709   724   736   748   759 #>  [6,]   583   624   658   687   718   737   753   761 #>  [7,]   577   619   645   675   706   727   740   750 #>  [8,]   668   712   740   760   775   785   789   795 #>  [9,]   615   661   683   713   731   753   769   783 #> [10,]   602   643   673   703   728   743   755   767 #>  #> $cases_cumul #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    0   14   26   53   92  134  180  231  304   384   462   530   600 #>  [2,]    0   19   56  121  197  297  388  494  572   625   672   700   726 #>  [3,]    0   10   25   42   72  115  157  219  302   388   476   555   615 #>  [4,]    0   13   50   77  141  218  311  413  529   602   657   703   745 #>  [5,]    0   16   60  102  171  236  312  391  478   549   598   632   660 #>  [6,]    0    8   24   52   89  150  221  303  380   475   538   595   644 #>  [7,]    0   17   44   97  149  208  280  346  404   481   541   582   623 #>  [8,]    0   16   35   61  123  216  300  391  494   567   634   685   722 #>  [9,]    0   13   26   55   91  134  181  258  373   475   554   630   673 #> [10,]    0   10   27   57   98  158  225  310  415   497   561   618   659 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] #>  [1,]   643   683   714   736   758   770   778   790 #>  [2,]   740   750   761   768   772   776   777   780 #>  [3,]   662   699   723   739   750   758   762   767 #>  [4,]   764   776   790   799   807   808   810   812 #>  [5,]   689   714   732   742   748   753   763   767 #>  [6,]   662   695   720   742   754   763   768   773 #>  [7,]   659   684   711   730   741   753   758   760 #>  [8,]   749   765   773   787   788   794   795   801 #>  [9,]   707   733   747   758   769   779   784   787 #> [10,]   689   711   728   742   750   758   764   766 #>  #> $cases_inc #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] #>  [1,]    0    4    3    6    8    7   13   12   12    17    12    16    12 #>  [2,]    0    3    9   17   16   18   10   21   11     5     7     5     2 #>  [3,]    0    2    4    5    4   13    8   13   16    23    19    17    10 #>  [4,]    0    5    7    7   15   20   22   23   22    13     8     4     9 #>  [5,]    0    6    9   12   12   18    9   15   15     9    11     5     6 #>  [6,]    0    2    2    7    6   13   21   18   21    21    13     7    10 #>  [7,]    0    6    4    7    8   13   18   13    7    14     6     3     9 #>  [8,]    0    2    4    5    7   21   22   14   21    12    10    15     4 #>  [9,]    0    5    2    6    4    7   14   17   20    18    20    11     6 #> [10,]    0    1    4    5    5   11   18   12   24    20    16    10     9 #>       [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] #>  [1,]     9     4     4     4     1     1     2     3 #>  [2,]     3     2     1     3     0     0     0     0 #>  [3,]     3     8     4     3     1     2     1     2 #>  [4,]     2     0     2     3     4     0     1     0 #>  [5,]     3     4     1     3     1     2     1     1 #>  [6,]     2     7     6     4     1     1     0     1 #>  [7,]     8     3     9     3     4     1     1     0 #>  [8,]     3     1     2     6     0     0     0     2 #>  [9,]     2     3     2     1     1     1     0     2 #> [10,]     6     6     4     3     0     2     0     0 #>   # Here, the list is named following the compartments (S, I, R, # etc) and is a 10 x 21 matrix (i.e., the remaining dimensions # from y)  # We could apply this to the final state, which converts a 5 x 10 # matrix of state into a 5 element list of vectors, each with # length 10: s <- dust_system_state(sys) dim(s) #> [1]  5 10 dust_unpack_state(sys, s) #> $S #>  [1] 200 210 223 178 223 217 230 189 203 224 #>  #> $I #>  [1] 32  5 20  9 18 22 20 16 14  9 #>  #> $R #>  [1] 768 785 757 813 759 761 750 795 783 767 #>  #> $cases_cumul #>  [1] 790 780 767 812 767 773 760 801 787 766 #>  #> $cases_inc #>  [1] 3 0 2 0 1 1 0 2 2 0 #>   # If you need more control, you can use 'dust_unpack_index' to map # names to positions within the state dimension of this array dust_unpack_index(sys) #> $S #> [1] 1 #>  #> $I #> [1] 2 #>  #> $R #> [1] 3 #>  #> $cases_cumul #> [1] 4 #>  #> $cases_inc #> [1] 5 #>"}]
