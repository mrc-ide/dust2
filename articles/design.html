<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Principles and design of dust • dust2</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Principles and design of dust">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">dust2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.28</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/dust2.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/design.html">Principles and design of dust</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Details</h6></li>
    <li><a class="dropdown-item" href="../articles/data.html">Comparing dust systems to data</a></li>
    <li><a class="dropdown-item" href="../articles/details.html">Details</a></li>
    <li><a class="dropdown-item" href="../articles/packaging.html">Packaging dust systems</a></li>
    <li><a class="dropdown-item" href="../articles/periodic.html">Periodic variables details</a></li>
    <li><a class="dropdown-item" href="../articles/writing.html">Writing dust2 systems</a></li>
    <li><a class="dropdown-item" href="../articles/migrating.html">Migrating from dust 1.x.x</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mrc-ide/dust2/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Principles and design of dust</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/mrc-ide/dust2/blob/main/vignettes/design.Rmd" class="external-link"><code>vignettes/design.Rmd</code></a></small>
      <div class="d-none name"><code>design.Rmd</code></div>
    </div>

    
    
<p>Fundamentally, using a computer to create a realisation from
stochastic Monte Carlo models is extremely simple. Consider a random
walk in one dimension - we might write that in base R functions by
creating a function that takes a current state <code>state</code> and a
list of parameters:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">update_walk</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">state</span>, <span class="va">pars</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">state</span>, <span class="va">pars</span><span class="op">$</span><span class="va">sd</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>and then iterating it for 20 time steps with:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span><span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>sd <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">20</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">y</span> <span class="op">&lt;-</span> <span class="fu">update_walk</span><span class="op">(</span><span class="va">y</span>, <span class="va">pars</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>At the end of this process, the variable <code>y</code> contains a
new value, corresponding to 20 time steps with our stochastic update
function.</p>
<p>So why does <code>dust</code> apparently require thousands of lines
of code to do this?</p>
<div class="section level2">
<h2 id="running-multiple-realisations">Running multiple realisations<a class="anchor" aria-label="anchor" href="#running-multiple-realisations"></a>
</h2>
<p>It’s very rare that one might want to run a single stochastic
simulation; normally we want to run a group together. There are several
ways that we might want to do that:</p>
<ul>
<li>For a single set of parameters and a starting state run a set of
simulations, as they will differ due to the stochasticity in the
model</li>
<li>In addition to the above, perhaps run with different starting
points, representing uncertainty in initial conditions</li>
<li>In addition to the above, run for many parameter sets at once
possibly with one particle per parameter, possibly with many per
parameter</li>
<li>In addition to the above, the parameters themselves are grouped into
blocks</li>
</ul>
<p>The book-keeping for this can get tedious and error prone if done by
hand. In <code>dust</code>, we try and restrict concern about this to a
few points, and for the simulation itself – the interaction that we
expect to take the longest in any interesting model – we just run a big
loop over time and all particles no matter what type of structure they
might represent from the above.</p>
<p>See <code>vignette("multi")</code> for details of interacting with
different ways that you might want to structure your simulations.</p>
</div>
<div class="section level2">
<h2 id="parallelisation">Parallelisation<a class="anchor" aria-label="anchor" href="#parallelisation"></a>
</h2>
<p>Once we’re running multiple simulations at once, even a simple
simulation might start taking a long time and because they are
independent we might look to parallelism to try and speed up the
simulations.</p>
<p>However, one cannot just draw multiple numbers from a single random
number generator at once. That is, given a generator like those built
into R, there is no parallel equivalent to</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<p>that would draw the 10 numbers in parallel rather than in series.
When drawing a random number there is a “<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" class="external-link">side
effect</a>” of updating the random number state. That is because the
random number stream is <em>also</em> a Markov chain!</p>
<p>As such it makes sense (to us at least) to store the state of each
stream’s random number generator separately, so if we have
<code>n</code> particles within a <code>dust</code> object we have
<code>n</code> separate streams, and we might think of the model state
as being the state that is declared by the user as a vector of floating
point numbers alongside the random number state. During each model step,
the model state is updated and so is the random number state.</p>
<p>This might seem wasteful, and if we used the popular <a href="https://en.wikipedia.org/wiki/Mersenne_Twister" class="external-link">Mersenne
Twister</a> it would be to some degree as each particle would require
2560 bytes of additional state. In contrast the newer <a href="https://prng.di.unimi.it/" class="external-link">xoshiro</a> generators that we use
require only 32 or 16 bytes of state; the same as 4 double- or
single-precision floating point numbers respectively. So for any
non-trivial simulation it’s not a very large overhead.</p>
<p>Setting the seed for these runs is not trivial, particularly as the
number of simultaneous particles increases. If you’ve used random
numbers with the <a href="https://cran.r-project.org/package=future" class="external-link">future</a> package you
may have seen it raise a warning if you do not configure it to use a
“L’Ecuyer-CMRG” which adapts R’s native random number seeds to be safe
in parallel.</p>
<p>The reason for this is that if different streams start from seeds
that are set via poor heuristics (e.g., system time and thread id) they
might be exactly the same. If they were set randomly, then they might
collide (see <a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/" class="external-link">John
Cook’s description of the birthday paradox here</a>) and if they are
picked sequentially there’s no guarantee that these streams might not be
correlated.</p>
<p>Ideally we want a similar set of properties to R’s
<code>set.seed</code> method; the user provides an arbitrary integer and
we seed <em>all</em> the random number streams using this in a way that
is reproducible and also statistically robust. We also want the streams
to be reproducible even when the number of particles changes, for
particle indices that are shared. The random number generators we use
(the xoshiro family, a.k.a. Blackmann-Vigna generators) support these
properties; they will be more fully described in <a href="https://mrc-ide.github.io/monty" class="external-link"><code>monty</code></a> where they
are implemented.</p>
<p>To initialise our system with a potentially very large number of
particles we take two steps:</p>
<ul>
<li>First, we seed the first stream using the <code>splitmix64</code>
RNG, following the xoshiro docs. This expands a single 64-bit integer
into the 256-bits of RNG state, while ensuring that the resulting full
random number seed does not contain all zeros.</li>
<li>Then, for each subsequent chain we take a “jump” in the sequence.
This is a special move implemented by the RNG that is equivalent to a
very large number of draws from the generator (e.g., about 2^128 for the
default generator used for double-precision models) ensuring that each
particles state occupies a non-overlapping section of the underlying
random number stream (see <code>vignette("rng")</code> for
details).</li>
</ul>
<p>With this setup we are free to parallelise the system as each
realisation is completely independent of all others; the problem has
become “<a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" class="external-link">embarrassingly
parallel</a>”. In practice we do this using <a href="https://www.openmp.org/" class="external-link">OpenMP</a> where available as this is
well supported from R and gracefully falls back on serial operation
where not available.</p>
<p>As the number of threads changes, the results will not change; the
same calculations will be carried out and the same random numbers
drawn.</p>
<p>Sometimes we might parallelise beyond one computer (e.g., when using
a cluster), in which case we cannot use OpenMP. We call this case
“distributed parallelism” and cope by having each process take a “long
jump” (an even larger jump in the random number space), then within the
process proceed as above. This is the approach taken in our <a href="https://mrc-ide.github.io/monty/" class="external-link"><code>monty</code></a> package
for organising running MCMC chains in parallel, each of which works with
a dust model.</p>
</div>
<div class="section level2">
<h2 id="efficient-running">Efficient running<a class="anchor" aria-label="anchor" href="#efficient-running"></a>
</h2>
<p>A general rule-of-thumb is to avoid unneeded memory allocations in
tight loops; with this sort of stochastic iteration everything is a
tight loop! However, we’ve reduced the problem scope to just providing
an update method, and as long as that does not issue memory allocations
then the whole thing runs in fixed space without having to worry.</p>
</div>
<div class="section level2">
<h2 id="efficient-state-handling">Efficient state handling<a class="anchor" aria-label="anchor" href="#efficient-state-handling"></a>
</h2>
<p>For non-trivial systems, we often want to record a subset of states -
potentially a very small fraction of the total states computed. For
example, in our <a href="https://mrc-ide.github.io/sircovid/" class="external-link"><code>sircovid</code></a>
model we track several thousand states (representing populations in
various stages of disease transmission, in different ages, with
different vaccination status etc), but most of the time we only need to
report on a few tens of these in order to fit to data or to examine key
outputs.</p>
<p>Reducing the number of state variables returned at different points
in the process has several advantages:</p>
<ul>
<li>Saving space: if you run a model with 2000 states, 1000 replicates
and record their trajectories over 100 time steps, that represents 100
million floating point numbers, or 1.6 GB of memory or disk if using
double-precision numbers. These are not unrealistic numbers, but would
make even a simple sensitivity analysis all-but impossible to work
with.</li>
<li>Saving time: copying data around is surprisingly slow.</li>
</ul>
<p>To enable this, you can restrict the state returned by most methods;
some by default and others when you call them.</p>
<ul>
<li>The <code><a href="../reference/dust_system_run_to_time.html">dust_system_run_to_time()</a></code> returns <em>no</em>
state, simply advances the system forward in time</li>
<li>The <code><a href="../reference/dust_system_simulate.html">dust_system_simulate()</a></code> method move the system
forwards in time and returns the state at a series of points. It accepts
an <code>index_state</code> argument to limit which states are
returned</li>
<li>The <code><a href="../reference/dust_system_state.html">dust_system_state()</a></code> method returns the model state
and accepts an argument <code>index_state</code> as the state to
return</li>
</ul>
<p>We use the idea of <a href="https://mrc-ide.github.io/monty/reference/monty_packer.html" class="external-link">“packers”,
from <code>monty</code></a> to help work with the state.</p>
<p>The ordering of the state is important; we always have dimensions
that will contain:</p>
<ol style="list-style-type: decimal">
<li>the model states within a single particle</li>
<li>the particles within a time-step (may be several dimensions; see
<code>vignette("multi")</code>)</li>
<li>the time dimension if using <code>simulate</code> or a particle
filter</li>
</ol>
<p>This is to minimise repeatedly moving around data during writing, and
to help with concatenation. Multiple particles data is stored
consecutively and read and written in order. Each time step is written
at once. And you can append states from different times easily. The
base-R <code><a href="https://rdrr.io/r/base/aperm.html" class="external-link">aperm()</a></code> function will be useful for reshaping this
output to a different dimension order if you require one, but it can be
very slow.</p>
<p>In order to pull all of this off, we allocate all our memory up
front, in C++ and pass back to R a “pointer” to this memory, which will
live for as long as your model object. This means that even if your
model requires gigabytes of memory to run, it is never copied back and
forth into R (where it would be subject to R’s <a href="https://en.wikipedia.org/wiki/Copy-on-write" class="external-link">copy-on-write
semantics</a> but instead accessed only when needed, and written to
in-place following C++ reference semantics.</p>
</div>
<div class="section level2">
<h2 id="useful-verbs">Useful verbs<a class="anchor" aria-label="anchor" href="#useful-verbs"></a>
</h2>
<p>We try and provide verbs that are useful, given that the model
presents a largely opaque pointer to model state.</p>
<p>Normally a system will contain several things:</p>
<ul>
<li>the random number state: this is effectively a matrix of integers
(either <code>uint32_t</code> or <code>uint64_t</code>)</li>
<li>the system state: this is effectively a matrix of floating point
numbers, (typically <code>double</code>)</li>
<li>some immutable “shared” state, that all particles within a parameter
group can read but not write while running (it can be updated between
runs). Because this is immutable it can be safely shared between all
copies of a system and accessed simultaneously by different
threads.</li>
<li>the system <em>internal state</em>, which is mutable and each
particle can both read and write to, but which is only used as a buffer
for calculations. We keep one of these per parameter set per thread so
that different threads can safely mutate their own state. Importantly,
this space is assumed to be unimportant to specifying model state (i.e.,
we can shuffle or reset the model state while leaving the “internal”
data behind).</li>
</ul>
<p>Given this, the sorts of verbs that we need include:</p>
<ul>
<li>Running the system up to a time point
(<code><a href="../reference/dust_system_run_to_time.html">dust_system_run_to_time()</a></code>) - runs the system’s
<code>update</code> method as many times as required to reach the new
time point, returning the model state at this time point. This is useful
where you might want to change the system at this time point, then
continue. For continuous time models we use an ODE solver using the
system’s <code>deriv</code> method to compute rates.</li>
<li>Running the model and collecting history
(<code><a href="../reference/dust_system_simulate.html">dust_system_simulate()</a></code>) - as for
<code><a href="../reference/dust_system_run_to_time.html">dust_system_run_to_time()</a></code> but also collects partial state
at a number of times along the way. This always has one more dimension
than <code><a href="../reference/dust_system_state.html">dust_system_state()</a></code> (being time).</li>
<li>Setting model state (<code><a href="../reference/dust_system_set_state.html">dust_system_set_state()</a></code>) - leaves
RNG state and parameters untouched but replaces model state for all
particles. This is useful for model initialisation and for performing
arbitrary model state and/or parameter changes.</li>
</ul>
<p>In addition, we have more specific methods oriented towards <a href="https://en.wikipedia.org/wiki/Particle_filter" class="external-link">particle
filtering</a>:</p>
<ul>
<li>Reordering the particles (<code><a href="../reference/dust_system_reorder.html">dust_system_reorder()</a></code>) -
shuffles particle state among particles within a parameter set. This is
useful for implementing resampling algorithms and updates only the state
(as for <code><a href="../reference/dust_system_set_state.html">dust_system_set_state()</a></code>, leaving RNG state and
internal state untouched)</li>
<li>Run a bootstrap particle filter (<code><a href="../reference/dust_filter_create.html">dust_filter_create()</a></code>)
which is implemented using the above methods, in the case where the
model provides a compare function. This provides an interface with
<code>monty</code> when used with
<code><a href="../reference/dust_likelihood_monty.html">dust_likelihood_monty()</a></code>
</li>
</ul>
</div>
<div class="section level2">
<h2 id="a-compilation-target">A compilation target<a class="anchor" aria-label="anchor" href="#a-compilation-target"></a>
</h2>
<p>The most esoteric design of dust is to make it convenient to use as a
target for other programs. We use the package primarily as a target for
models written in <a href="https://mrc-ide.github.io/odin2/" class="external-link"><code>odin2</code></a>. This
allows the user to write models at a very high level, describing the
updates between steps. The random walk example at the beginning of this
document might be implemented as</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sd</span> <span class="op">&lt;-</span> <span class="fu">parameter</span><span class="op">(</span><span class="op">)</span>          <span class="co"># user-provided standard deviation</span></span>
<span><span class="fu">initial</span><span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fl">0</span>            <span class="co"># starting point of the simulation</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/update.html" class="external-link">update</a></span><span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu">Normal</span><span class="op">(</span><span class="va">y</span>, <span class="va">sd</span><span class="op">)</span> <span class="co"># take random step each time step</span></span></code></pre></div>
<p>We have designed these two systems to play well together so the user
can write models at a very high level and generate code that then works
well within this framework and efficiently runs in parallel. In <a href="https://mrc-ide.github.io/sircovid/" class="external-link"><code>sircovid</code></a>
this is used in a model with hundreds of logical compartments each of
which may be structured, but the interface at the R level remains the
same as for the toy models used in the documentation here.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Rich FitzJohn.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
