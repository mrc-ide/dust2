<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en-GB">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Periodic variables details • dust2</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet">
<meta property="og:title" content="Periodic variables details">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">dust2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.28</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/dust2.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/design.html">Principles and design of dust</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Details</h6></li>
    <li><a class="dropdown-item" href="../articles/data.html">Comparing dust systems to data</a></li>
    <li><a class="dropdown-item" href="../articles/details.html">Details</a></li>
    <li><a class="dropdown-item" href="../articles/packaging.html">Packaging dust systems</a></li>
    <li><a class="dropdown-item" href="../articles/periodic.html">Periodic variables details</a></li>
    <li><a class="dropdown-item" href="../articles/writing.html">Writing dust2 systems</a></li>
    <li><a class="dropdown-item" href="../articles/migrating.html">Migrating from dust 1.x.x</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mrc-ide/dust2/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Periodic variables details</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/mrc-ide/dust2/blob/main/vignettes/periodic.Rmd" class="external-link"><code>vignettes/periodic.Rmd</code></a></small>
      <div class="d-none name"><code>periodic.Rmd</code></div>
    </div>

    
    
<p>This vignette describes the algorithm used for periodic resetting,
which is used in systems that need to calculate incidence. For example,
suppose that you have a system you are fitting to case data (e.g., the
number of new cases per day) and your system is a discrete time system
that updates in intervals of 1/10 a day. To do this you would typically
accumulate new cases over each fractional day until the day is complete,
then you would reset this variable to zero at the start of the next day.
Here we outline how we perform this calculation for both types of
systems in discrete time (which is quite straightforward) and in
continuous time (which is more complex), along with the assumptions we
make about the sorts of values that will be accumulated in this way, and
details about exactly when resetting happens, especially in the context
of comparison to data.</p>
<p>This vignette is intended as documentation for the package authors
and for very interested parties. <strong>You do not need to read or
understand this vignette to use the package.</strong></p>
<div class="section level2">
<h2 id="discrete-time-systems">Discrete time systems<a class="anchor" aria-label="anchor" href="#discrete-time-systems"></a>
</h2>
<p>We start with discrete time systems because they’re much easier to
think about, and consider the case of the SIR system in the package,
which we’ll write out by hand here (we could relax this if we tweaked
<code>simulate</code> to allow returning fractional days, I think).</p>
<p>The relevant section of the <code><a href="https://rdrr.io/r/stats/update.html" class="external-link">update()</a></code> method looks like
this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S <span class="op">=</span> state<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> I <span class="op">=</span> state<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> p_SI <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> monty<span class="op">::</span>math<span class="op">::</span>exp<span class="op">(-</span>shared<span class="op">.</span>beta <span class="op">*</span> I <span class="op">/</span> shared<span class="op">.</span>N <span class="op">*</span> dt<span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> n_SI <span class="op">=</span> monty<span class="op">::</span>random<span class="op">::</span>binomial<span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;(</span>rng_state<span class="op">,</span> S<span class="op">,</span> p_SI<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>state_next<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">+=</span> n_SI<span class="op">;</span></span></code></pre></div>
<p>Here, we unpack <code>S</code> and <code>I</code> from the state
vector, compute the per-individual probability of moving from
<code>S</code> to <code>I</code> (<code>p_SI</code>), then draw a total
number of individuals to move from <code>S</code> to <code>I</code>
(<code>n_SI</code>) using the binomial distribution. Finally, we
accumulate that into the incidence state (<code>state_next[4]</code>).
Here, we don’t do anything to cause this to reset each day. Instead, we
define a <code>zero_every</code> method which arranges this for us:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="at">static</span> <span class="kw">auto</span> zero_every<span class="op">(</span><span class="at">const</span> shared_state<span class="op">&amp;</span> shared<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span class="cf">return</span> dust2<span class="op">::</span><span class="dt">zero_every_type</span><span class="op">&lt;</span><span class="dt">real_type</span><span class="op">&gt;{{</span><span class="dv">1</span><span class="op">,</span> <span class="op">{</span><span class="dv">4</span><span class="op">}}};</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The initializer-list syntax is a bit gory but <code>{{1, {4}}}</code>
reads as “every 1 time unit zero the variables at index 4”, which is
what we want to do.</p>
<p>When running the system we apply the <code>update</code> function
over and over, so the daily cases increases. At the end of a day (so in
the step that increases time to an integer value) the incidence value
will be at its peak, and that is what is returned by
<code><a href="../reference/dust_system_state.html">dust_system_state()</a></code> after the system has been run.</p>
<p>The zeroing happens just before the first call to
<code><a href="https://rdrr.io/r/stats/update.html" class="external-link">update()</a></code> at the start of the run away from an eligible
time. So even though the system operates in discrete time you can think
of this as happening at <code>t + eps</code>.</p>
<p>Doing this trick for discrete time models is easy because we are
guaranteed to visit each time step in turn, and because we guarantee
that each integer-valued time will be visited (eventually), and we
require that the periods used for resetting are themselves integer-like
(you cannot compute 0.25-daily incidence for example).</p>
</div>
<div class="section level2">
<h2 id="continuous-time-systems">Continuous time systems<a class="anchor" aria-label="anchor" href="#continuous-time-systems"></a>
</h2>
<p>It turns out we can do the same trick in continuous time systems,
too, though it’s much less obvious how it works. With a continuous time
system, the difficulty is that we can’t be guaranteed to land on exactly
the times corresponding to the reset periods, though it turns out that
most of the time we probably will because these will typically align
with the places that we have data.</p>
<p>Consider again resetting some variables immediately at the start of a
step. We end up performing this check at every step. We look to see if
we have passed over a reset time in the <em>previous</em> step. To do
this we consider events along a real line, and with the time at the end
of the previous step and our current step we compute, for each interval
in question, how many complete divisions of the interval are possible.
If both the previous step and current step have <code>n</code> divisions
(that is,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⌊</mo><msub><mi>t</mi><mi>i</mi></msub><mi>/</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>d</mi><mo stretchy="false" form="postfix">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor t_i / period \rfloor</annotation></semantics></math>)
then they are within the same period and no reset is required, but if
the current step has more divisions than the previous then we have
passed one (or more) resettings.</p>
<p><img src="periodic_files/figure-html/unnamed-chunk-2-1.png" width="700"></p>
<p>Consider the figure which illustrates the situation. Time runs along
the x axis in days, and dotted vertical lines indicate beginnings of
weeks (every 7 days, as is conventional). The first pair of points in
the figure move from day 15 to 18, both of which are in week 2
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⌊</mo><mn>15</mn><mi>/</mi><mn>2</mn><mo stretchy="false" form="postfix">⌋</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\lfloor 15 / 2 \rfloor = 2</annotation></semantics></math>);
at the end of this step we don’t need to consider resetting any weekly
variables.</p>
<p>The middle pair of points run from day 19 to 24, crossing from the
middle of week 2 to week 3. At the end of the previous step, any
weekly-reset variables hold values that need resetting, and we will need
to do this before continuing the integration. The third set of points
also need resetting; they have landed exactly at the boundary of week 2
and 3, so the first thing that we need to do on starting is reset the
values to accumulate for week 3. This situation is very common as we’ll
often have resetting variables aligned with data, and the solver will
stop exactly at the times with data.</p>
<p>In the fourth case, we jump over <em>two</em> reset values, but this
is OK too, even though we never hold a correct value through week 2, we
also never <em>use</em> that value in week 2. We still need to reset
before continuing as we’ve crossed at least one boundary.</p>
<p>Having decided to reset, we then need to make the changes to the
values. In the case where we have landed exactly at a boundary (which is
more common than you’d think; see above) this is very easy; we can just
zero the value of our variables in question!</p>
<p>In the case where we are part-way through an interval this is more
complex though. This is true for the second and fourth cases above. We
need to compute the value of the target function at the time of reset
and subtract this off of the current value of the variables to be reset.
To do this we exploit the Dormand-Prince solver’s “dense output”, which
allows us to interpolate any variable over the interval of the previous
interval. In the fourth case where we have jumped over two intervals,
this calculation only happens for the final interval.</p>
<p>There’s one remaining wrinkle, which is what happens at the very end
of the integration. Consider the points above to be the final steps
taken by the solver at the end of the integration (so at the beginning
of the step our resetting variables were corrected as above). In this
case, for the <em>fourth</em> case we have a problem in that the step
has passed into a new interval so we need to apply a reset. Here our
step has taken us from 13 through to 25 jumping over resets at 14 and
21. We look up the value of the variables at 21 and subtract them from
the final values held, so that we now have only values accumulated
during week 3.</p>
</div>
<div class="section level2">
<h2 id="properties-of-resettable-variables">Properties of resettable variables<a class="anchor" aria-label="anchor" href="#properties-of-resettable-variables"></a>
</h2>
<p>The implementation here makes some assumptions about your variables
which are hard to prove by <code>dust2</code> itself, so you are
responsible for satisfying them. We’ll try and make sure that
<code>odin2</code> can satisfy these for you so that you never need to
worry about it though (even more than you don’t need to worry about
anything in this vignette).</p>
<p>They accumulate only; for ode systems they have a rate of ingress
that does not depend on themselves and they are never read by any other
part of the system. This is important because at many parts of the
integration they will hold the incorrect value. For discrete time
systems they should be an incremental addition (e.g., with
<code>+=</code>).</p>
</div>
<div class="section level2">
<h2 id="unresolved-bits-that-might-change">Unresolved bits that might change<a class="anchor" aria-label="anchor" href="#unresolved-bits-that-might-change"></a>
</h2>
<p>It’s not possible to offset where the reset happens; if it’s every 1
unit then it happens at times 0, 1, 2, etc. If it’s every 7 units it
will be at time 0, 7, 14, etc.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Rich FitzJohn.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
