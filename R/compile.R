##' Compile a dust2 system from a C++ input file.  This function will
##' compile the dust support around your system and return an object
##' that you can call with no arguments to make a
##' `dust_system_generator` object, suitable for using with dust
##' functions (starting from [dust_system_create]).
##'
##' @title Compile a dust2 system
##'
##' @param filename The path to a single C++ file
##'
##' @param quiet Logical, indicating if compilation messages from
##'   `pkgbuild` should be displayed.  Error messages will be
##'   displayed on compilation failure regardless of the value used.
##'   If `NULL` is given, then we take the value from `DUST_QUIET` if set, or
##'   `FALSE` otherwise.
##'
##' @param workdir Optional working directory to use.  If `NULL`, the
##'   behaviour depends on the existence of the environment variable
##'   `DUST_WORKDIR_ROOT`.  If it is unset we use a session-specific
##'   temporary directory (generated by [tempfile()]).  If
##'   `DUST_WORKDIR_ROOT` is set, then we use a stable generated
##'   filename within this directory, which allows different sessions
##'   to effectively share a cache.  If you pass a directory name here
##'   as a string, then we will use that directory to write all code,
##'   which allows you to inspect the generated code.  See
##'   `vignette("details")` for more information.
##'
##' @param linking_to Optionally, a character vector of additional
##'   packages to add to the `DESCRIPTION`'s `LinkingTo` field. Use
##'   this when your system pulls in C++ code that is packaged within
##'   another package's header-only library.
##'
##' @param cpp_std The C++ standard to use, if you need to set one
##'   explicitly. See the section "Using C++ code" in "Writing R
##'   extensions" for the details of this, and how it interacts with
##'   the R version currently being used. For R 4.0.0 and above, C++11
##'   will be used; as dust depends on at least this version of R you
##'   will never need to specify a version this low. Sensible options
##'   are `C++14`, `C++17`, etc, depending on the features you need
##'   and what your compiler supports.
##'
##' @param compiler_options A character vector of additional options
##'   to pass through to the C++ compiler. These will be passed
##'   through without any shell quoting or validation, so check the
##'   generated commands and outputs carefully in case of error. Note
##'   that R will apply these *before* anything in your personal
##'   `Makevars`.
##'
##' @param optimisation_level A shorthand way of specifying common
##'   compiler options that control optimisation level. By default
##'   (`NULL`) no options are generated from this, and the
##'   optimisation level will depend on your user `Makevars` file.
##'   Valid options are `none` which disables optimisation (`-O0`),
##'   which will be faster to compile but much slower, `standard`
##'   which enables standard level of optimisation (`-O2`), useful if
##'   your Makevars/pkgload configuration is disabling optimisation,
##'   or `max` (`-O3` and `--fast-math`) which enables some
##'   slower-to-compile and [potentially
##'   unsafe](https://simonbyrne.github.io/notes/fastmath/)
##'   optimisations.  These options are applied *after*
##'   `compiler_options` and may override options provided there.
##'   Note that as for `compiler_options`, R will apply these *before*
##'   anything in your personal `Makevars`
##'
##' @param debug Passed to [pkgbuild::compile_dll], this will build a
##'   debug library.
##'
##' @param skip_cache Logical, indicating if the cache of previously
##'   compiled systems should be skipped. If `TRUE` then your system will
##'   not be looked for in the cache, nor will it be added to the
##'   cache after compilation.
##'
##' @return A function, which can be called with no arguments to yield
##'   a `dust_system_generator` function.
##'
##' @export
dust_compile <- function(filename, quiet = NULL, workdir = NULL,
                         linking_to = NULL, cpp_std = NULL,
                         compiler_options = NULL, optimisation_level = NULL,
                         debug = FALSE, skip_cache = FALSE) {
  stop_unless_installed(dust_compile_needs())
  config <- parse_metadata(filename, call = environment())
  mangle <- substr(rlang::hash_file(filename), 1, 8)
  res <- dust_generate(config, filename, linking_to, cpp_std,
                       optimisation_level, compiler_options, mangle)

  ## Cache on code and all options.
  hash <- rlang::hash(c(res, debug = debug))
  if (!skip_cache && !is.null(cache$generators[[hash]])) {
    if (!quiet) {
      cli::cli_alert_info("Using cached generator")
    }
    return(cache$generators[[hash]]$gen)
  }

  workdir <- dust_workdir(workdir, hash)
  quiet <- dust_quiet(quiet)
  dir_create(c(workdir, file.path(workdir, c("R", "src"))))
  writelines_if_changed(res$description, workdir, "DESCRIPTION", quiet)
  writelines_if_changed(res$namespace, workdir, "NAMESPACE", quiet)
  writelines_if_changed(res$r, workdir, "R/dust.R", quiet)
  writelines_if_changed(res$cpp, workdir, "src/dust.cpp", quiet)
  writelines_if_changed(res$makevars, workdir, "src/Makevars", quiet)
  pkgbuild::compile_dll(workdir, compile_attributes = TRUE,
                        quiet = quiet, debug = debug)
  env <- load_temporary_package(workdir, res$package, quiet)
  dll <- file.path(workdir, "src", paste0(res$package, .Platform$dynlib.ext))
  gen <- env[[config$name]]

  if (!skip_cache) {
    cache$generators[[hash]] <- list(
      name = config$name,
      time = Sys.time(),
      package = res$package,
      env = env,
      dll = dll,
      gen = gen)
  }

  gen
}


dust_generate <- function(config, filename, linking_to, cpp_std,
                          optimisation_level, compiler_options, mangle) {
  system <- read_lines(filename)
  data <- dust_template_data(config$name, config$class, config$time_type,
                             config$default_dt, linking_to, cpp_std,
                             optimisation_level, compiler_options, mangle)
  data$system_requirements <- data$cpp_std %||% "R (>= 4.0.0)"

  list(
    package = data$package,
    config = config,
    description = substitute_dust_template(data, "DESCRIPTION"),
    namespace = substitute_dust_template(data, "NAMESPACE"),
    makevars = substitute_dust_template(data, "Makevars"),
    r = substitute_dust_template(data, "dust.R"),
    cpp = dust_generate_cpp(system, config, data))
}


dust_generate_cpp <- function(system, config, data) {
  time_type <- config$time_type
  includes <- c("cpp11.hpp", sprintf("dust2/r/%s/system.hpp", time_type))
  code <- c(
    substitute_dust_template(data, file.path(time_type, "system.cpp")),
    substitute_dust_template(data, "system.cpp"))

  header <- sprintf(
    "// Generated by dust2 (version %s) - do not edit",
    data$dust_version)

  if (config$has_compare) {
    includes <- c(includes,
                  sprintf("dust2/r/%s/filter.hpp", time_type),
                  sprintf("dust2/r/%s/unfilter.hpp", time_type))
    code <- c(
      code,
      "",
      substitute_dust_template(data, file.path(time_type, "compare.cpp")),
      substitute_dust_template(data, "compare.cpp"))
  }
  if (config$has_adjoint) {
    code <- c(
      code,
      "",
      substitute_dust_template(data, "adjoint.cpp"))
  }
  c(header,
    "",
    system,
    "",
    sprintf("#include <%s>", includes),
    "",
    code)
}


dust_template_data <- function(name,
                               class,
                               time_type,
                               default_dt,
                               linking_to = NULL,
                               cpp_std = NULL,
                               optimisation_level = NULL,
                               compiler_options = NULL,
                               mangle = NULL) {

  if (!is.null(linking_to)) {
    assert_character(linking_to)
  }
  linking_to <- paste(union(c("cpp11", "dust2", "monty"), linking_to),
                      collapse = ", ")
  cpp_std <- validate_cpp_std(cpp_std)
  compiler_options <- validate_compiler_options(compiler_options,
                                                optimisation_level)
  list(name = name,
       class = class,
       time_type = time_type,
       default_dt = deparse1(default_dt),
       package = paste0(name, mangle %||% ""),
       linking_to = linking_to,
       cpp_std = cpp_std,
       compiler_options = compiler_options)
}


validate_compiler_options <- function(compiler_options, optimisation_level) {
  if (!is.null(optimisation_level)) {
    opts <- switch(
      optimisation_level,
      none = "-O0",
      standard = "-O2",
      max = c("-O3", "-ffast-math"),
      cli::cli_abort(
        "Unknown 'optimisation_level' value '{optimisation_level}'"))
    compiler_options <- c(compiler_options, opts)
  }
  paste(compiler_options, collapse = " ")
}


validate_cpp_std <- function(cpp_std, call = NULL) {
  if (is.null(cpp_std)) {
    return(NULL)
  }
  assert_scalar_character(cpp_std, call = call)
  is_valid <- grepl("^C\\+\\+[0-9][0-9a-z]$", cpp_std, ignore.case = TRUE)
  if (!is_valid) {
    cli::cli_abort(
      "'cpp_std' does not look like a valid C++ standard name (e.g., C++14)",
      arg = "cpp_std", call = call)
  }
  cpp_std
}


dust_compile_needs <- function() {
  strsplit(utils::packageDescription("dust2")[["Config/Needs/compile"]],
           ",\\s+")[[1]]
}


substitute_dust_template <- function(data, src) {
  glue_whisker(read_lines(dust2_file(file.path("template", src))), data)
}


load_temporary_package <- function(path, base, quiet) {
  pkg <- pkgload::load_all(path, compile = FALSE, recompile = FALSE,
                           warn_conflicts = FALSE, export_all = FALSE,
                           helpers = FALSE, attach_testthat = FALSE,
                           quiet = quiet)
  detach(paste0("package:", base), character.only = TRUE)
  pkg$env
}


dust_workdir <- function(path, hash, call = parent.frame()) {
  if (is.null(path)) {
    pattern <- "dust_"
    root <- Sys.getenv("DUST_WORKDIR_ROOT", NA_character_)
    if (is.na(root)) {
      path <- tempfile(pattern)
    } else {
      path <- file.path(root, paste0(pattern, substr(hash, 1, 7)))
    }
  } else if (file.exists(path)) {
    if (!is_directory(path)) {
      cli::cli_abort("Path '{path}' already exists but is not a directory",
                     call = call)
    }
    contents <- c(
      dir(path, all.files = TRUE, no.. = TRUE),
      file.path("src", dir(file.path(path, "src"),
                           all.files = TRUE, no.. = TRUE)),
      file.path("R", dir(file.path(path, "R"),
                           all.files = TRUE, no.. = TRUE)))
    contents <- contents[!grepl(".+\\.(o|so|dll)", contents)]
    allowed <- c("DESCRIPTION", "NAMESPACE", "src", "R",
                 "src/Makevars", "src/dust.cpp", "R/dust.R",
                 "src/cpp11.cpp", "R/cpp11.R")
    extra <- setdiff(contents, allowed)
    if (length(extra)) {
      cli::cli_abort("Path '{path}' does not look like a dust directory",
                     call = call)
    }
  }
  path
}


dust_quiet <- function(quiet, call = parent.frame()) {
  if (is.null(quiet)) {
    envvar_is_truthy("DUST_QUIET")
  } else {
    assert_scalar_logical(quiet, call = call)
  }
}
